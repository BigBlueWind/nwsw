/**
 ****************************************************************************
 *
 * @file dejitter.c
 *
 * @brief Source code file for Mindspeed Transcede EVM Dejitter and clock
 * routing PLL driver software.  
 *
 * @copyright
 * This software is Copyright (c) 2010-2011 Mindspeed Technologies Inc., 
 * All rights reserved.
 *
 * @par Address of Copyright holder
 * <pre>
 *       Mindspeed Technologies, Inc.
 *       4000 MACARTHUR BLVD - EAST TOWER
 *       NEWPORT BEACH, CA 92660
 * </pre>


* @par license
 * GNU Public License version 2.0
 *
 * This software is included as part of u-boot and therefore this particular
 * source file is licensed under the terms of the GNU Public License version
 * 2.0. 
 *
 * @par NOTE
 * Different EVMs use different PLLs and have different capabilities.
 * This file is a consolodation to support Mindspeed x670, x730 and x750
 * Evaluation and demostration boards.
 * 
 ******************************************************************************/
#include "dejitter.h"
#include "appprintf.h"
#include <string.h>
#include "spidrv.h"
#include "clkrst.h"

// Base defines for enabling/disabling chips
#define TI_CDCE_62005 1
#define AD9548        1 
#define AD9553        1

#define GHZ_SYSCLK

// Dejitter debug defines (turns on printf, additional checking, etc.
//#define DEBUG_DEJITTER


//
// Defines for clock selection of TSU clock period
// 8  nanoseconds gives the best accuracy for timestamp resolution
// 10 nanoseconds is a little easier to debug as time ticks in a power of 10 nanoseconds
//
// #define CLKA_8_NS_PERIOD  1 // 125 MHz clock in
   #define CLKA_10_NS_PERIOD 1 // 100 MHz clock in

#include "i2cdrv.h"
#include "ad9548_19_2_mhz_tcxo.h"

#define CYPRESS_I2C_ADDRESS                 (0x69 << 1)

// Lower I2C register base, 0x08-0x17 (16 registers)
// Note: Cypress program generates registers 0x08-0x1B, 
//       Datasheet describes ..... registers 0x08-0x17
// Only programming what is in the datasheet for now
// and not what is listed as reserved by the program
//
#define CYPRESS_I2C_LOWER_REGISTER_BASE     0x08
#define CYPRESS_I2C_LOWER_REGISTER_COUNT    16

// Upper I2C register base, 0x40-0x57 (24 registers)
#define CYPRESS_I2C_UPPER_REGISTER_BASE     0x40
#define CYPRESS_I2C_UPPER_REGISTER_COUNT    24

/* Generated by Alan K. Bartky 2010-08-22
 * Using Cypress CyClocksRT imported into
 * Excel template to generate C code
 */

/* 
    _____   _____________________
   / __\ \ / / _ \ _ \ __/ __/ __|
  | (__ \ ^ /|  _/   / _|\__ \__ \
   \___| |_| |_| |_|_\___|___/___/ TIMING TECHNOLOGY
  ==================================================

                     ______________         
                   _|*    \__/     |_  ________ 
             CLKC |_| 1         16 |_| SHUTDOWN/OE 
                   _|              |_     _______
              VDD |_| 2         15 |_| S2/SUSPEND 
                   _|              |_       
             AGND |_| 3         14 |_| AVDD 
                   _|              |_       
           XTALIN |_| 4         13 |_| SCLK 
                   _|   CY22393    |_       
          XTALOUT |_| 5         12 |_| SDAT 
                   _|              |_       
             XBUF |_| 6         11 |_| GND  
                   _|              |_       
             CLKD |_| 7         10 |_| CLKA 
                   _|              |_       
             CLKE |_| 8          9 |_| CLKB 
                    |______________|        


Generated by CyClocksRT R3.10.00            

Modification Date: 8/22/2010
Comments: 
Customer: 
FAE: 
License #: bm0kd1gd1-ns6ps0cc2

*/
#ifdef CLKA_10_NS_PERIOD
/************************
 * 38.4 MHz "config 2": *
 ************************/

/**************************************************************************
 * REF:   38.4 MHz input                                                  *
 * CLKA: 100.00000  MHz output  TSU 10 ns clock tick for IEEE 1588 engine *
 * CLKB:  12.800000 MHz output  Clock for Sync                            *
 * CLKC:  30.720000 MHz output  Radio Clock                               *
 * CLKD:  10.000000 MHz output  CPRI calibrated clock 0 (other usage)     *
 * CLKE: 154.809449 MHz output  CPRI calibrated clock 1 (used for CPRI)   *
 **************************************************************************/



/**
 *
 <pre>
Reference Input:   38.400000 MHz External

PLL 1:     Entry 0:     P: 1024  Q: 127
           Entry 1:     P: 1024  Q: 127
PLL 2:                  P: 125   Q: 16
PLL 3:                  P: 48    Q: 5

=============================================================
| Pll  |  S2   | Source|  Desired   |   Actual   |   PPM    |
=============================================================
| Pll3 |   -   |  Ref  | 368.640000 | 368.640000 | 0.0      |
| Pll2 |   -   |  Ref  | 300.000000 | 300.000000 | 0.0      |
| Pll1 |   0   |  Ref  | 309.618898 | 309.618898 | -0.0     |
| Pll1 |   1   |  Ref  | 309.618898 | 309.618898 | -0.0     |
=============================================================

Clock Output

=========================================================================
|Output|  S2   |  Source  |  Desired   |   Actual   |   PPM    | Voltage|
=========================================================================
| XBUF |   -   |  Ref     |  38.400000 |  38.400000 |     +0.0 |  3.3V  |
| CLKE |   0   |  Pll1/2  | 154.809449 | 154.809449 |     -0.0 |  3.3V  |
| CLKE |   1   |  Pll1/2  | 154.809449 | 154.809449 |     -0.0 |  3.3V  |
| CLKD |   -   |  Pll2/30 |  10.000000 |  10.000000 |     +0.0 |  3.3V  |
| CLKC |   -   |  Pll3/12 |  30.720000 |  30.720000 |     +0.0 |  3.3V  |
| CLKB |   -   |  Ref /3  |  12.800000 |  12.800000 |     +0.0 |  3.3V  |
| CLKA |   -   |  Pll2/3  | 100.000000 | 100.000000 |     +0.0 |  3.3V  |
=========================================================================
</pre>
*/


const UINT8 CypressConfigDataLowerRegisters38_4MHzInput[] =
{
    (0x00<<7) | /* 08H: [7..7] Asrc: ClkA Phase Select, DivSel low: 0b0(0) */
    (0x03<<0) , /*      [6..0] Adiv: ClkA Divider, DivSel low: 0b0000011(3) */
    (0x00<<7) | /* 09H: [7..7] Asrc: ClkA Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0AH: [7..7] Bsrc: ClkB Phase Select, DivSel low: 0b0(0) */
    (0x03<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel low: 0b0000011(3) */
    (0x00<<7) | /* 0BH: [7..7] Bsrc: ClkB Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0CH: [7..7] Csrc: ClkC Phase Select: 0b0(0) */
    (0x0C<<0) , /*      [6..0] Cdiv: ClkC Divider: 0b0001100(12) */
    (0x00<<7) | /* 0DH: [7..7] Dsrc[0]: ClkD Phase Select: 0b0(0) */
    (0x1E<<0) , /*      [6..0] Ddiv: ClkD Divider: 0b0011110(30) */
    (0x02<<6) | /* 0EH: [7..6] Dsrc[2:1]: ClkD Source Select: 0b10(2) */
    (0x03<<4) | /*      [5..4] Csrc[2:1]: ClkC Source Select: 0b11(3) */
    (0x00<<2) | /*      [3..2] Bsrc[2:1]: ClkB Source Select: 0b00(0) */
    (0x02<<0) , /*      [1..0] Asrc[2:1]: ClkA Source Select: 0b10(2) */
    (0x01<<6) | /* 0FH: [7..6] dty13: Bank1, Bank3 duty cycle setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] dty02: Bank0, bank2 duty cycle setting: 0b01(1) */
    (0x00<<3) | /*      [3..3] PdnEn: Enables Powerdown when OE is low: 0b0(0) */
    (0x01<<2) | /*      [2..2] ClkXEn: ClkX Output Enable: 0b1(1) */
    (0x02<<0) , /*      [1..0] Ediv: ClkE Divider: 0b10(2) */
    (0x01<<6) | /* 10H: [7..6] drvX: Bank3 (Xbuff) drive setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] drvDE: Bank2 (ClkD, ClkE) drive setting: 0b01(1) */
    (0x01<<2) | /*      [3..2] drvC: Bank1 (ClkC) drive setting: 0b01(1) */
    (0x01<<0) , /*      [1..0] drvAB: Bank0 (ClkA, ClkB) drive setting: 0b01(1) */
    (0x0E<<0) , /* 11H: [7..0] PLL2_QB: PLL2 8-bit Loadable Q-Counter: 0b00001110(14) */
    (0x3B<<0) , /* 12H: [7..0] PLL2_PB[7:0]: PLL2 Lower 8 bits of 10-bit Loadable base P counter: 0b00111011(59) */
    (0x00<<7) | /* 13H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll2En: Enables PLL2 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL2_Pump: PLL2 Charge pump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL2_PO[0]: PLL2 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL2_PB[9:8]: PLL2 Upper 2 bits of 10-bit loadable base P counter: 0b00(0) */
    (0x03<<0) , /* 14H: [7..0] PLL3_QB: PLL3 8-bit Loadable Q counter: 0b00000011(3) */
    (0x15<<0) , /* 15H: [7..0] PLL3_PB[7:0]: PLL3 Lower 8 bits of 10-bit Loadable base P counter: 0b00010101(21) */
    (0x00<<7) | /* 16H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll3En: Enables PLL3 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL3_Pump: PLL3 Charge pump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL3_PO[0]: PLL3 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL3_PB[9:8]: PLL3 Upper 2 bits  of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<2) | /* 17H: [7..2] xcap: Oscillator Load Capacitance Setting(6 MSB): 0b000000(0) */
    (0x01<<0) , /*      [1..0] xgm: Oscillator Inverter Drive Setting: 0b01(1) */
    (0x00<<7) | /* 18H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x00<<7) | /* 19H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x01<<7) | /* 1AH: [7..7] Reserved: Reserved: 0b1(1) */
    (0x69<<0) , /*      [6..0] Reserved: Reserved: 0b1101001(105) */
    (0x08<<0) , /* 1BH: [7..0] Reserved: Reserved: 0b00001000(8) */
};

const UINT8 CypressConfigDataUpperRegisters38_4MHzInput[] =
{
    (0x7D<<0) , /* 40H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 41H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 42H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 43H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 44H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 45H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 46H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 47H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 48H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 49H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 4AH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 4BH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 4CH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 4DH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 4EH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 4FH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 50H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 51H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 52H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 53H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 54H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 55H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 56H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 57H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
};

/**
 * @brief Clocking for testing on low cost EVM with 40 MHz input from
 * AD9361 radio module into as reference clock into the CY22393 and
 * where output clock is synchronized to that.  
 * 
 * @details
 * Note that there is no CPRI
 * calibrated clock as it is not possible to generate that frequency from 40
 * MHz in and get the other clocks needed.  CPRI calibrated clock is not
 * needed in radio mode anyway
 * 
 * <pre>
 * 
Generated by CyClocksRT R3.10.00            
Modification Date: 6/20/2011

Comments: Clock for radio testing on low cost EVM, 
          40 MHz in from radio module, 
          10 MHz out to IXIA, 
          100 MHz to TSU
Customer: Mindspeed
Created by: Alan K. Bartky (Mindspeed)
License #: bm0kd1gd1-ns6ps0cc2

Reference Input:   40.000000 MHz External
PLL 1:         Entry 0:     P: 1152     Q: 125
               Entry 1:     P: 0        Q: 0
PLL 2:                      P: 248      Q: 25
PLL 3:                      P: 20       Q: 2

=============================================================
| Pll  |  S2   | Source|  Desired   |   Actual   |   PPM    |
=============================================================
| Pll3 |   -   |  Ref  | 400.000000 | 400.000000 | 0.0      |
| Pll2 |   -   |  Ref  | 396.800000 | 396.800000 | 0.0      |
| Pll1 |   0   |  Ref  | 368.640000 | 368.640000 | 0.0      |
| Pll1 |   1   |  Ref  |    Off     |    Off     |   Off    |
=============================================================

Clock Output
=========================================================================
|Output|  S2   |  Source  |  Desired   |   Actual   |   PPM    | Voltage|
=========================================================================
| XBUF |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKE |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKD |   -   |  Ref /4  |  10.000000 |  10.000000 |     +0.0 |  3.3V  |
| CLKC |   0   |  Pll1/12 |  30.720000 |  30.720000 |     +0.0 |  3.3V  |
| CLKC |   1   |  Pll1/12 |    Off     |    Off     |   Off    |  3.3V  |
| CLKB |   -   |  Pll2/31 |  12.800000 |  12.800000 |     +0.0 |  3.3V  |
| CLKA |   -   |  Pll3/4  | 100.000000 | 100.000000 |     +0.0 |  3.3V  |
=========================================================================

 * </pre>
 */

const UINT8 CypressConfigDataLowerRegisters40MHzInput[] =
{
    (0x00<<7) | /* 08H: [7..7] Asrc: ClkA Phase Select, DivSel low: 0b0(0) */
    (0x04<<0) , /*      [6..0] Adiv: ClkA Divider, DivSel low: 0b0000100(4) */
    (0x00<<7) | /* 09H: [7..7] Asrc: ClkA Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0AH: [7..7] Bsrc: ClkB Phase Select, DivSel low: 0b0(0) */
    (0x1F<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel low: 0b0011111(31) */
    (0x00<<7) | /* 0BH: [7..7] Bsrc: ClkB Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0CH: [7..7] Csrc: ClkC Phase Select: 0b0(0) */
    (0x0C<<0) , /*      [6..0] Cdiv: ClkC Divider: 0b0001100(12) */
    (0x00<<7) | /* 0DH: [7..7] Dsrc[0]: ClkD Phase Select: 0b0(0) */
    (0x04<<0) , /*      [6..0] Ddiv: ClkD Divider: 0b0000100(4) */
    (0x00<<6) | /* 0EH: [7..6] Dsrc[2:1]: ClkD Source Select: 0b00(0) */
    (0x01<<4) | /*      [5..4] Csrc[2:1]: ClkC Source Select: 0b01(1) */
    (0x02<<2) | /*      [3..2] Bsrc[2:1]: ClkB Source Select: 0b10(2) */
    (0x03<<0) , /*      [1..0] Asrc[2:1]: ClkA Source Select: 0b11(3) */
    (0x01<<6) | /* 0FH: [7..6] dty13: Bank1, Bank3 duty cycle setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] dty02: Bank0, bank2 duty cycle setting: 0b01(1) */
    (0x00<<3) | /*      [3..3] PdnEn: Enables Powerdown when OE is low: 0b0(0) */
    (0x00<<2) | /*      [2..2] ClkXEn: ClkX Output Enable: 0b0(0) */
    (0x00<<0) , /*      [1..0] Ediv: ClkE Divider: 0b00(0) */
    (0x01<<6) | /* 10H: [7..6] drvX: Bank3 (Xbuff) drive setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] drvDE: Bank2 (ClkD, ClkE) drive setting: 0b01(1) */
    (0x01<<2) | /*      [3..2] drvC: Bank1 (ClkC) drive setting: 0b01(1) */
    (0x01<<0) , /*      [1..0] drvAB: Bank0 (ClkA, ClkB) drive setting: 0b01(1) */
    (0x17<<0) , /* 11H: [7..0] PLL2_QB: PLL2 8-bit Loadable Q-Counter: 0b00010111(23) */
    (0x79<<0) , /* 12H: [7..0] PLL2_PB[7:0]: PLL2 Lower 8 bits of 10-bit Loadable base P counter: 0b01111001(121) */
    (0x00<<7) | /* 13H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll2En: Enables PLL2 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL2_Pump: PLL2 Charge pump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL2_PO[0]: PLL2 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL2_PB[9:8]: PLL2 Upper 2 bits of 10-bit loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 14H: [7..0] PLL3_QB: PLL3 8-bit Loadable Q counter: 0b00000000(0) */
    (0x07<<0) , /* 15H: [7..0] PLL3_PB[7:0]: PLL3 Lower 8 bits of 10-bit Loadable base P counter: 0b00000111(7) */
    (0x00<<7) | /* 16H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll3En: Enables PLL3 when high: 0b1(1) */
    (0x00<<3) | /*      [5..3] PLL3_Pump: PLL3 Charge pump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL3_PO[0]: PLL3 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL3_PB[9:8]: PLL3 Upper 2 bits  of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<2) | /* 17H: [7..2] xcap: Oscillator Load Capacitance Setting(6 MSB): 0b000000(0) */
    (0x01<<0) , /*      [1..0] xgm: Oscillator Inverter Drive Setting: 0b01(1) */
    (0x00<<7) | /* 18H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x00<<7) | /* 19H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x01<<7) | /* 1AH: [7..7] Reserved: Reserved: 0b1(1) */
    (0x69<<0) , /*      [6..0] Reserved: Reserved: 0b1101001(105) */
    (0x08<<0) , /* 1BH: [7..0] Reserved: Reserved: 0b00001000(8) */
};

const UINT8 CypressConfigDataUpperRegisters40MHzInput[] =
{
    (0x7B<<0) , /* 40H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111011(123) */
    (0x3D<<0) , /* 41H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00111101(61) */
    (0x00<<7) | /* 42H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x02<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b10(2) */
    (0x7B<<0) , /* 43H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111011(123) */
    (0x3D<<0) , /* 44H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00111101(61) */
    (0x00<<7) | /* 45H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x02<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b10(2) */
    (0x7B<<0) , /* 46H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111011(123) */
    (0x3D<<0) , /* 47H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00111101(61) */
    (0x00<<7) | /* 48H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x02<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b10(2) */
    (0x7B<<0) , /* 49H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111011(123) */
    (0x3D<<0) , /* 4AH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00111101(61) */
    (0x00<<7) | /* 4BH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x02<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b10(2) */
    (0x00<<0) , /* 4CH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 4DH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 4EH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4FH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 50H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 51H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 52H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 53H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 54H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 55H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 56H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 57H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
};



/**
 @brief Programming structure for Femtocell reference board 153.6 MHz clock in, 100 MHz TSU clock out
 @details
 <pre>
Comments: T4K Femtocell reference design, 153.6 MHz clock in, 100 MHz TSU clock out


Reference Input:  153.600000 MHz External
PLL 1:     Entry 0:     P: 256     Q: 127
           Entry 1:     P: 0       Q: 0
PLL 2:                  P: 75      Q: 32
PLL 3:                  P: 125     Q: 64

=============================================================
| Pll  |  S2   | Source|  Desired   |   Actual   |   PPM    |
=============================================================
| Pll3 |   -   |  Ref  | 300.000000 | 300.000000 | 0.0      |
| Pll2 |   -   |  Ref  | 360.000000 | 360.000000 | 0.0      |
| Pll1 |   0   |  Ref  | 309.618898 | 309.618898 | -0.0     |
| Pll1 |   1   |  Ref  |    Off     |    Off     |   Off    |
=============================================================



Clock Output
=========================================================================
|Output|  S2   |  Source  |  Desired   |   Actual   |   PPM    | Voltage|
=========================================================================
| XBUF |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKE |   0   |  Pll1/2  | 154.809449 | 154.809449 |     -0.0 |  3.3V  |
| CLKE |   1   |  Pll1/2  |    Off     |    Off     |   Off    |  3.3V  |
| CLKD |   0   |  Pll1/2  | 154.809449 | 154.809449 |     -0.0 |  3.3V  |
| CLKD |   1   |  Pll1/2  |    Off     |    Off     |   Off    |  3.3V  |
| CLKC |   -   |  Ref /5  |  30.720000 |  30.720000 |     +0.0 |  3.3V  |
| CLKB |   -   |  Pll2/9  |  40.000000 |  40.000000 |     +0.0 |  3.3V  |
| CLKA |   -   |  Pll3/3  | 100.000000 | 100.000000 |     +0.0 |  3.3V  |
=========================================================================

 </pre>
 */

const UINT8 CypressConfigDataLowerRegistersFemtocell[] =
{
    (0x00<<7) | /* 08H: [7..7] Asrc: ClkA Phase Select, DivSel low: 0b0(0) */
    (0x03<<0) , /*      [6..0] Adiv: ClkA Divider, DivSel low: 0b0000011(3) */
    (0x00<<7) | /* 09H: [7..7] Asrc: ClkA Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0AH: [7..7] Bsrc: ClkB Phase Select, DivSel low: 0b0(0) */
    (0x09<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel low: 0b0001001(9) */
    (0x00<<7) | /* 0BH: [7..7] Bsrc: ClkB Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0CH: [7..7] Csrc: ClkC Phase Select: 0b0(0) */
    (0x05<<0) , /*      [6..0] Cdiv: ClkC Divider: 0b0000101(5) */
    (0x00<<7) | /* 0DH: [7..7] Dsrc[0]: ClkD Phase Select: 0b0(0) */
    (0x02<<0) , /*      [6..0] Ddiv: ClkD Divider: 0b0000010(2) */
    (0x01<<6) | /* 0EH: [7..6] Dsrc[2:1]: ClkD Source Select: 0b01(1) */
    (0x00<<4) | /*      [5..4] Csrc[2:1]: ClkC Source Select: 0b00(0) */
    (0x02<<2) | /*      [3..2] Bsrc[2:1]: ClkB Source Select: 0b10(2) */
    (0x03<<0) , /*      [1..0] Asrc[2:1]: ClkA Source Select: 0b11(3) */
    (0x01<<6) | /* 0FH: [7..6] dty13: Bank1, Bank3 duty cycle setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] dty02: Bank0, bank2 duty cycle setting: 0b01(1) */
    (0x00<<3) | /*      [3..3] PdnEn: Enables Powerdown when OE is low: 0b0(0) */
    (0x00<<2) | /*      [2..2] ClkXEn: ClkX Output Enable: 0b0(0) */
    (0x00<<0) , /*      [1..0] Ediv: ClkE Divider: 0b00(0) */
    (0x01<<6) | /* 10H: [7..6] drvX: Bank3 (Xbuff) drive setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] drvDE: Bank2 (ClkD, ClkE) drive setting: 0b01(1) */
    (0x01<<2) | /*      [3..2] drvC: Bank1 (ClkC) drive setting: 0b01(1) */
    (0x01<<0) , /*      [1..0] drvAB: Bank0 (ClkA, ClkB) drive setting: 0b01(1) */
    (0x1E<<0) , /* 11H: [7..0] PLL2_QB: PLL2 8-bit Loadable Q-Counter: 0b00011110(30) */
    (0x22<<0) , /* 12H: [7..0] PLL2_PB[7:0]: PLL2 Lower 8 bits of 10-bit Loadable base P counter: 0b00100010(34) */
    (0x00<<7) | /* 13H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll2En: Enables PLL2 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL2_Pump: PLL2 Charge pump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL2_PO[0]: PLL2 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL2_PB[9:8]: PLL2 Upper 2 bits of 10-bit loadable base P counter: 0b00(0) */
    (0x3E<<0) , /* 14H: [7..0] PLL3_QB: PLL3 8-bit Loadable Q counter: 0b00111110(62) */
    (0x3B<<0) , /* 15H: [7..0] PLL3_PB[7:0]: PLL3 Lower 8 bits of 10-bit Loadable base P counter: 0b00111011(59) */
    (0x00<<7) | /* 16H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll3En: Enables PLL3 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL3_Pump: PLL3 Charge pump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL3_PO[0]: PLL3 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL3_PB[9:8]: PLL3 Upper 2 bits  of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<2) | /* 17H: [7..2] xcap: Oscillator Load Capacitance Setting(6 MSB): 0b000000(0) */
    (0x03<<0) , /*      [1..0] xgm: Oscillator Inverter Drive Setting: 0b11(3) */
    (0x00<<7) | /* 18H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x00<<7) | /* 19H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x01<<7) | /* 1AH: [7..7] Reserved: Reserved: 0b1(1) */
    (0x69<<0) , /*      [6..0] Reserved: Reserved: 0b1101001(105) */
    (0x08<<0) , /* 1BH: [7..0] Reserved: Reserved: 0b00001000(8) */
};

const UINT8 CypressConfigDataUpperRegistersFemtocell[] =
{
    (0x7D<<0) , /* 40H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0x7D<<0) , /* 41H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b01111101(125) */
    (0x00<<7) | /* 42H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x7D<<0) , /* 43H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0x7D<<0) , /* 44H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b01111101(125) */
    (0x00<<7) | /* 45H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x7D<<0) , /* 46H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0x7D<<0) , /* 47H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b01111101(125) */
    (0x00<<7) | /* 48H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x7D<<0) , /* 49H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0x7D<<0) , /* 4AH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b01111101(125) */
    (0x00<<7) | /* 4BH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4CH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 4DH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 4EH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4FH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 50H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 51H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 52H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 53H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 54H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 55H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 56H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 57H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
};




#endif

#ifdef CLKA_8_NS_PERIOD

/**
<pre>
 ***********************
 * 38.4 MHz "config 3": *
 ************************
**************************************************************************
 * REF:   38.4 MHz input                                                  *
 * CLKA: 125.00000  MHz output  TSU 8 ns clock tick for IEEE 1588 engine  *
 * CLKB:  12.800000 MHz output  Clock for Sync                            *
 * CLKC:  30.720000 MHz output  Radio Clock                               *
 * CLKD:  10.000000 MHz output  CPRI calibrated clock 0 (other usage)     *
 * CLKE: 154.809449 MHz output  CPRI calibrated clock 1 (used for CPRI)   *
 **************************************************************************


Reference Input:   38.400000 MHz External

PLL 1:     Entry 0:     P: 1024  Q: 127
           Entry 1:     P: 0     Q: 0
PLL 2:                  P: 625   Q: 96
PLL 3:                  P: 48    Q: 5

=============================================================
| Pll  |  S2   | Source|  Desired   |   Actual   |   PPM    |
=============================================================
| Pll3 |   -   |  Ref  | 368.640000 | 368.640000 | 0.0      |
| Pll2 |   -   |  Ref  | 250.000000 | 250.000000 | 0.0      |
| Pll1 |   0   |  Ref  | 309.618898 | 309.618898 | -0.0     |
| Pll1 |   1   |  Ref  | 309.618898 | 309.618898 | -0.0     |
=============================================================

Clock Output
=========================================================================
|Output|  S2   |  Source  |  Desired   |   Actual   |   PPM    | Voltage|
=========================================================================
| XBUF |   -   |  Ref     |  38.400000 |  38.400000 |     +0.0 |  3.3V  |
| CLKE |   0   |  Pll1/2  | 154.809449 | 154.809449 |     -0.0 |  3.3V  |
| CLKE |   1   |  Pll1/2  | 154.809449 | 154.809449 |     -0.0 |  3.3V  |
| CLKD |   -   |  Pll2/25 |  10.000000 |  10.000000 |     +0.0 |  3.3V  |
| CLKC |   -   |  Pll3/12 |  30.720000 |  30.720000 |     +0.0 |  3.3V  |
| CLKB |   -   |  Ref /3  |  12.800000 |  12.800000 |     +0.0 |  3.3V  |
| CLKA |   -   |  Pll2/2  | 125.000000 | 125.000000 |     +0.0 |  3.3V  |
=========================================================================
</pre>
*/

const UINT8 CypressConfigDataLowerRegisters38_4MHzInput[] =
{
    (0x00<<7) | /* 08H: [7..7] Asrc: ClkA Phase Select, DivSel low: 0b0(0) */
    (0x02<<0) , /*      [6..0] Adiv: ClkA Divider, DivSel low: 0b0000010(2) */
    (0x00<<7) | /* 09H: [7..7] Asrc: ClkA Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0AH: [7..7] Bsrc: ClkB Phase Select, DivSel low: 0b0(0) */
    (0x03<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel low: 0b0000011(3) */
    (0x00<<7) | /* 0BH: [7..7] Bsrc: ClkB Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0CH: [7..7] Csrc: ClkC Phase Select: 0b0(0) */
    (0x0C<<0) , /*      [6..0] Cdiv: ClkC Divider: 0b0001100(12) */
    (0x00<<7) | /* 0DH: [7..7] Dsrc[0]: ClkD Phase Select: 0b0(0) */
    (0x19<<0) , /*      [6..0] Ddiv: ClkD Divider: 0b0011001(25) */
    (0x02<<6) | /* 0EH: [7..6] Dsrc[2:1]: ClkD Source Select: 0b10(2) */
    (0x03<<4) | /*      [5..4] Csrc[2:1]: ClkC Source Select: 0b11(3) */
    (0x00<<2) | /*      [3..2] Bsrc[2:1]: ClkB Source Select: 0b00(0) */
    (0x02<<0) , /*      [1..0] Asrc[2:1]: ClkA Source Select: 0b10(2) */
    (0x01<<6) | /* 0FH: [7..6] dty13: Bank1, Bank3 duty cycle setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] dty02: Bank0, bank2 duty cycle setting: 0b01(1) */
    (0x00<<3) | /*      [3..3] PdnEn: Enables Powerdown when OE is low: 0b0(0) */
    (0x01<<2) | /*      [2..2] ClkXEn: ClkX Output Enable: 0b1(1) */
    (0x02<<0) , /*      [1..0] Ediv: ClkE Divider: 0b10(2) */
    (0x01<<6) | /* 10H: [7..6] drvX: Bank3 (Xbuff) drive setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] drvDE: Bank2 (ClkD, ClkE) drive setting: 0b01(1) */
    (0x01<<2) | /*      [3..2] drvC: Bank1 (ClkC) drive setting: 0b01(1) */
    (0x01<<0) , /*      [1..0] drvAB: Bank0 (ClkA, ClkB) drive setting: 0b01(1) */
    (0x5E<<0) , /* 11H: [7..0] PLL2_QB: PLL2 8-bit Loadable Q-Counter: 0b01011110(94) */
    (0x35<<0) , /* 12H: [7..0] PLL2_PB[7:0]: PLL2 Lower 8 bits of 10-bit Loadable base P counter: 0b00110101(53) */
    (0x00<<7) | /* 13H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll2En: Enables PLL2 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL2_Pump: PLL2 Charge pump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL2_PO[0]: PLL2 Offset Counter: 0b1(1) */
    (0x01<<0) , /*      [1..0] PLL2_PB[9:8]: PLL2 Upper 2 bits of 10-bit loadable base P counter: 0b01(1) */
    (0x03<<0) , /* 14H: [7..0] PLL3_QB: PLL3 8-bit Loadable Q counter: 0b00000011(3) */
    (0x15<<0) , /* 15H: [7..0] PLL3_PB[7:0]: PLL3 Lower 8 bits of 10-bit Loadable base P counter: 0b00010101(21) */
    (0x00<<7) | /* 16H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll3En: Enables PLL3 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL3_Pump: PLL3 Charge pump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL3_PO[0]: PLL3 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL3_PB[9:8]: PLL3 Upper 2 bits  of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<2) | /* 17H: [7..2] xcap: Oscillator Load Capacitance Setting(6 MSB): 0b000000(0) */
    (0x01<<0) , /*      [1..0] xgm: Oscillator Inverter Drive Setting: 0b01(1) */
    (0x00<<7) | /* 18H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x00<<7) | /* 19H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x01<<7) | /* 1AH: [7..7] Reserved: Reserved: 0b1(1) */
    (0x69<<0) , /*      [6..0] Reserved: Reserved: 0b1101001(105) */
    (0x08<<0) , /* 1BH: [7..0] Reserved: Reserved: 0b00001000(8) */
};

const UINT8 CypressConfigDataUpperRegisters38_4MHzInput[] =
{
    (0x7D<<0) , /* 40H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 41H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 42H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 43H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 44H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 45H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 46H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 47H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 48H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 49H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 4AH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 4BH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 4CH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 4DH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 4EH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 4FH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 50H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 51H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 52H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 53H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 54H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
    (0x7D<<0) , /* 55H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0xFD<<0) , /* 56H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b11111101(253) */
    (0x00<<7) | /* 57H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x01<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b01(1) */
};

/**
 * @brief Clocking for testing on low cost EVM with 40 MHz input from
 * AD9361 radio module into as reference clock into the CY22393 and
 * where output clock is synchronized to that.  
 * 
 * @details
 * Note that there is no CPRI
 * calibrated clock as it is not possible to generate that frequency from 40
 * MHz in and get the other clocks needed.  CPRI calibrated clock is not
 * needed in radio mode anyway
 * 
 * <pre>

Generated by CyClocksRT R3.10.00            

Modification Date: 6/20/2011
Comments: Clock for radio testing on low cost EVM, 
          40 MHz in from radio module, 
          10 MHz out to IXIA, 
          125 MHz to TSU
Customer: Mindspeed
Created by: Alan K. Bartky (Mindspeed)
License #: bm0kd1gd1-ns6ps0cc2

Reference Input:   40.000000 MHz External
PLL 1:         Entry 0:     P: 1152     Q: 125
               Entry 1:     P: 0        Q: 0
PLL 2:                      P: 248      Q: 25
PLL 3:                      P: 75       Q: 8

=============================================================
| Pll  |  S2   | Source|  Desired   |   Actual   |   PPM    |
=============================================================
| Pll3 |   -   |  Ref  | 375.000000 | 375.000000 | 0.0      |
| Pll2 |   -   |  Ref  | 396.800000 | 396.800000 | 0.0      |
| Pll1 |   0   |  Ref  | 368.640000 | 368.640000 | 0.0      |
| Pll1 |   1   |  Ref  |    Off     |    Off     |   Off    |
=============================================================

Clock Output
=========================================================================
|Output|  S2   |  Source  |  Desired   |   Actual   |   PPM    | Voltage|
=========================================================================
| XBUF |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKE |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKD |   -   |  Ref /4  |  10.000000 |  10.000000 |     +0.0 |  3.3V  |
| CLKC |   0   |  Pll1/12 |  30.720000 |  30.720000 |     +0.0 |  3.3V  |
| CLKC |   1   |  Pll1/12 |    Off     |    Off     |   Off    |  3.3V  |
| CLKB |   -   |  Pll2/31 |  12.800000 |  12.800000 |     +0.0 |  3.3V  |
| CLKA |   -   |  Pll3/3  | 125.000000 | 125.000000 |     +0.0 |  3.3V  |
=========================================================================
 * </pre>
 */

const UINT8 CypressConfigDataLowerRegisters40MHzInput[] =
{
    (0x00<<7) | /* 08H: [7..7] Asrc: ClkA Phase Select, DivSel low: 0b0(0) */
    (0x03<<0) , /*      [6..0] Adiv: ClkA Divider, DivSel low: 0b0000011(3) */
    (0x00<<7) | /* 09H: [7..7] Asrc: ClkA Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0AH: [7..7] Bsrc: ClkB Phase Select, DivSel low: 0b0(0) */
    (0x1F<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel low: 0b0011111(31) */
    (0x00<<7) | /* 0BH: [7..7] Bsrc: ClkB Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0CH: [7..7] Csrc: ClkC Phase Select: 0b0(0) */
    (0x0C<<0) , /*      [6..0] Cdiv: ClkC Divider: 0b0001100(12) */
    (0x00<<7) | /* 0DH: [7..7] Dsrc[0]: ClkD Phase Select: 0b0(0) */
    (0x04<<0) , /*      [6..0] Ddiv: ClkD Divider: 0b0000100(4) */
    (0x00<<6) | /* 0EH: [7..6] Dsrc[2:1]: ClkD Source Select: 0b00(0) */
    (0x01<<4) | /*      [5..4] Csrc[2:1]: ClkC Source Select: 0b01(1) */
    (0x02<<2) | /*      [3..2] Bsrc[2:1]: ClkB Source Select: 0b10(2) */
    (0x03<<0) , /*      [1..0] Asrc[2:1]: ClkA Source Select: 0b11(3) */
    (0x01<<6) | /* 0FH: [7..6] dty13: Bank1, Bank3 duty cycle setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] dty02: Bank0, bank2 duty cycle setting: 0b01(1) */
    (0x00<<3) | /*      [3..3] PdnEn: Enables Powerdown when OE is low: 0b0(0) */
    (0x00<<2) | /*      [2..2] ClkXEn: ClkX Output Enable: 0b0(0) */
    (0x00<<0) , /*      [1..0] Ediv: ClkE Divider: 0b00(0) */
    (0x01<<6) | /* 10H: [7..6] drvX: Bank3 (Xbuff) drive setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] drvDE: Bank2 (ClkD, ClkE) drive setting: 0b01(1) */
    (0x01<<2) | /*      [3..2] drvC: Bank1 (ClkC) drive setting: 0b01(1) */
    (0x01<<0) , /*      [1..0] drvAB: Bank0 (ClkA, ClkB) drive setting: 0b01(1) */
    (0x17<<0) , /* 11H: [7..0] PLL2_QB: PLL2 8-bit Loadable Q-Counter: 0b00010111(23) */
    (0x79<<0) , /* 12H: [7..0] PLL2_PB[7:0]: PLL2 Lower 8 bits of 10-bit Loadable base P counter: 0b01111001(121) */
    (0x00<<7) | /* 13H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll2En: Enables PLL2 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL2_Pump: PLL2 Charge pump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL2_PO[0]: PLL2 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL2_PB[9:8]: PLL2 Upper 2 bits of 10-bit loadable base P counter: 0b00(0) */
    (0x06<<0) , /* 14H: [7..0] PLL3_QB: PLL3 8-bit Loadable Q counter: 0b00000110(6) */
    (0x22<<0) , /* 15H: [7..0] PLL3_PB[7:0]: PLL3 Lower 8 bits of 10-bit Loadable base P counter: 0b00100010(34) */
    (0x00<<7) | /* 16H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll3En: Enables PLL3 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL3_Pump: PLL3 Charge pump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL3_PO[0]: PLL3 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL3_PB[9:8]: PLL3 Upper 2 bits  of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<2) | /* 17H: [7..2] xcap: Oscillator Load Capacitance Setting(6 MSB): 0b000000(0) */
    (0x01<<0) , /*      [1..0] xgm: Oscillator Inverter Drive Setting: 0b01(1) */
    (0x00<<7) | /* 18H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x00<<7) | /* 19H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x01<<7) | /* 1AH: [7..7] Reserved: Reserved: 0b1(1) */
    (0x69<<0) , /*      [6..0] Reserved: Reserved: 0b1101001(105) */
    (0x08<<0) , /* 1BH: [7..0] Reserved: Reserved: 0b00001000(8) */
};

const UINT8 CypressConfigDataUpperRegisters40MHzInput[] =
{
    (0x7B<<0) , /* 40H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111011(123) */
    (0x3D<<0) , /* 41H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00111101(61) */
    (0x00<<7) | /* 42H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x02<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b10(2) */
    (0x7B<<0) , /* 43H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111011(123) */
    (0x3D<<0) , /* 44H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00111101(61) */
    (0x00<<7) | /* 45H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x02<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b10(2) */
    (0x7B<<0) , /* 46H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111011(123) */
    (0x3D<<0) , /* 47H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00111101(61) */
    (0x00<<7) | /* 48H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x02<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b10(2) */
    (0x7B<<0) , /* 49H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111011(123) */
    (0x3D<<0) , /* 4AH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00111101(61) */
    (0x00<<7) | /* 4BH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x02<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b10(2) */
    (0x00<<0) , /* 4CH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 4DH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 4EH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4FH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 50H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 51H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 52H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 53H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 54H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 55H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 56H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 57H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
};


/**
 @brief Programming structure for Femtocell reference board 153.6 MHz clock in, 125 MHz TSU clock out
 @details
 <pre>
Comments: T4K Femtocell reference design, 153.6 MHz clock in, 125 MHz TSU clock out


Reference Input:  153.600000 MHz External
PLL 1:     Entry 0:     P: 256     Q: 127
           Entry 1:     P: 0       Q: 0
PLL 2:                  P: 75      Q: 32
PLL 3:                  P: 625     Q: 256

=============================================================
| Pll  |  S2   | Source|  Desired   |   Actual   |   PPM    |
=============================================================
| Pll3 |   -   |  Ref  | 375.000000 | 375.000000 | 0.0      |
| Pll2 |   -   |  Ref  | 360.000000 | 360.000000 | 0.0      |
| Pll1 |   0   |  Ref  | 309.618898 | 309.618898 | -0.0     |
| Pll1 |   1   |  Ref  |    Off     |    Off     |   Off    |
=============================================================

Clock Output
=========================================================================
|Output|  S2   |  Source  |  Desired   |   Actual   |   PPM    | Voltage|
=========================================================================
| XBUF |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKE |   -   |   Off    |    Off     |    Off     |   Off    |  3.3V  |
| CLKD |   0   |  Pll1/2  | 154.809449 | 154.809449 |     -0.0 |  3.3V  |
| CLKD |   1   |  Pll1/2  |    Off     |    Off     |   Off    |  3.3V  |
| CLKC |   -   |  Ref /5  |  30.720000 |  30.720000 |     +0.0 |  3.3V  |
| CLKB |   -   |  Pll2/9  |  40.000000 |  40.000000 |     +0.0 |  3.3V  |
| CLKA |   -   |  Pll3/3  | 125.000000 | 125.000000 |     +0.0 |  3.3V  |
=========================================================================

 </pre>
 */

const UINT8 CypressConfigDataLowerRegistersFemtocell[] =
{
    (0x00<<7) | /* 08H: [7..7] Asrc: ClkA Phase Select, DivSel low: 0b0(0) */
    (0x03<<0) , /*      [6..0] Adiv: ClkA Divider, DivSel low: 0b0000011(3) */
    (0x00<<7) | /* 09H: [7..7] Asrc: ClkA Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0AH: [7..7] Bsrc: ClkB Phase Select, DivSel low: 0b0(0) */
    (0x09<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel low: 0b0001001(9) */
    (0x00<<7) | /* 0BH: [7..7] Bsrc: ClkB Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0CH: [7..7] Csrc: ClkC Phase Select: 0b0(0) */
    (0x05<<0) , /*      [6..0] Cdiv: ClkC Divider: 0b0000101(5) */
    (0x00<<7) | /* 0DH: [7..7] Dsrc[0]: ClkD Phase Select: 0b0(0) */
    (0x02<<0) , /*      [6..0] Ddiv: ClkD Divider: 0b0000010(2) */
    (0x01<<6) | /* 0EH: [7..6] Dsrc[2:1]: ClkD Source Select: 0b01(1) */
    (0x00<<4) | /*      [5..4] Csrc[2:1]: ClkC Source Select: 0b00(0) */
    (0x02<<2) | /*      [3..2] Bsrc[2:1]: ClkB Source Select: 0b10(2) */
    (0x03<<0) , /*      [1..0] Asrc[2:1]: ClkA Source Select: 0b11(3) */
    (0x01<<6) | /* 0FH: [7..6] dty13: Bank1, Bank3 duty cycle setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] dty02: Bank0, bank2 duty cycle setting: 0b01(1) */
    (0x00<<3) | /*      [3..3] PdnEn: Enables Powerdown when OE is low: 0b0(0) */
    (0x00<<2) | /*      [2..2] ClkXEn: ClkX Output Enable: 0b0(0) */
    (0x00<<0) , /*      [1..0] Ediv: ClkE Divider: 0b00(0) */
    (0x01<<6) | /* 10H: [7..6] drvX: Bank3 (Xbuff) drive setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] drvDE: Bank2 (ClkD, ClkE) drive setting: 0b01(1) */
    (0x01<<2) | /*      [3..2] drvC: Bank1 (ClkC) drive setting: 0b01(1) */
    (0x01<<0) , /*      [1..0] drvAB: Bank0 (ClkA, ClkB) drive setting: 0b01(1) */
    (0x1E<<0) , /* 11H: [7..0] PLL2_QB: PLL2 8-bit Loadable Q-Counter: 0b00011110(30) */
    (0x22<<0) , /* 12H: [7..0] PLL2_PB[7:0]: PLL2 Lower 8 bits of 10-bit Loadable base P counter: 0b00100010(34) */
    (0x00<<7) | /* 13H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll2En: Enables PLL2 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL2_Pump: PLL2 Charge pump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL2_PO[0]: PLL2 Offset Counter: 0b1(1) */
    (0x00<<0) , /*      [1..0] PLL2_PB[9:8]: PLL2 Upper 2 bits of 10-bit loadable base P counter: 0b00(0) */
    (0xFE<<0) , /* 14H: [7..0] PLL3_QB: PLL3 8-bit Loadable Q counter: 0b11111110(254) */
    (0x35<<0) , /* 15H: [7..0] PLL3_PB[7:0]: PLL3 Lower 8 bits of 10-bit Loadable base P counter: 0b00110101(53) */
    (0x00<<7) | /* 16H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x01<<6) | /*      [6..6] Pll3En: Enables PLL3 when high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL3_Pump: PLL3 Charge pump Current Setting: 0b100(4) */
    (0x01<<2) | /*      [2..2] PLL3_PO[0]: PLL3 Offset Counter: 0b1(1) */
    (0x01<<0) , /*      [1..0] PLL3_PB[9:8]: PLL3 Upper 2 bits  of 10-bit Loadable base P counter: 0b01(1) */
    (0x00<<2) | /* 17H: [7..2] xcap: Oscillator Load Capacitance Setting(6 MSB): 0b000000(0) */
    (0x03<<0) , /*      [1..0] xgm: Oscillator Inverter Drive Setting: 0b11(3) */
    (0x00<<7) | /* 18H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x00<<7) | /* 19H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x01<<7) | /* 1AH: [7..7] Reserved: Reserved: 0b1(1) */
    (0x69<<0) , /*      [6..0] Reserved: Reserved: 0b1101001(105) */
    (0x08<<0) , /* 1BH: [7..0] Reserved: Reserved: 0b00001000(8) */
};

const UINT8 CypressConfigDataUpperRegistersFemtocell[] =
{
    (0x7D<<0) , /* 40H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0x7D<<0) , /* 41H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b01111101(125) */
    (0x00<<7) | /* 42H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x7D<<0) , /* 43H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0x7D<<0) , /* 44H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b01111101(125) */
    (0x00<<7) | /* 45H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x7D<<0) , /* 46H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0x7D<<0) , /* 47H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b01111101(125) */
    (0x00<<7) | /* 48H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x7D<<0) , /* 49H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b01111101(125) */
    (0x7D<<0) , /* 4AH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b01111101(125) */
    (0x00<<7) | /* 4BH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x01<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b1(1) */
    (0x04<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b100(4) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4CH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 4DH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 4EH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4FH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 50H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 51H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 52H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 53H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 54H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 55H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 56H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 57H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
};



#endif

const UINT8 CypressConfigDataLowerRegistersDisabled[] =
{
    (0x00<<7) | /* 08H: [7..7] Asrc: ClkA Phase Select, DivSel low: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA Divider, DivSel low: 0b0000000(0) */
    (0x00<<7) | /* 09H: [7..7] Asrc: ClkA Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Adiv: ClkA divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0AH: [7..7] Bsrc: ClkB Phase Select, DivSel low: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel low: 0b0000000(0) */
    (0x00<<7) | /* 0BH: [7..7] Bsrc: ClkB Phase Select, DivSel high: 0b0(0) */
    (0x00<<0) , /*      [6..0] Bdiv: ClkB Divider, DivSel high: 0b0000000(0) */
    (0x00<<7) | /* 0CH: [7..7] Csrc: ClkC Phase Select: 0b0(0) */
    (0x05<<0) , /*      [6..0] Cdiv: ClkC Divider: 0b0000101(5) */
    (0x00<<7) | /* 0DH: [7..7] Dsrc[0]: ClkD Phase Select: 0b0(0) */
    (0x00<<0) , /*      [6..0] Ddiv: ClkD Divider: 0b0000000(0) */
    (0x00<<6) | /* 0EH: [7..6] Dsrc[2:1]: ClkD Source Select: 0b00(0) */
    (0x00<<4) | /*      [5..4] Csrc[2:1]: ClkC Source Select: 0b00(0) */
    (0x00<<2) | /*      [3..2] Bsrc[2:1]: ClkB Source Select: 0b00(0) */
    (0x00<<0) , /*      [1..0] Asrc[2:1]: ClkA Source Select: 0b00(0) */
    (0x01<<6) | /* 0FH: [7..6] dty13: Bank1, Bank3 duty cycle setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] dty02: Bank0, bank2 duty cycle setting: 0b01(1) */
    (0x00<<3) | /*      [3..3] PdnEn: Enables Powerdown when OE is low: 0b0(0) */
    (0x00<<2) | /*      [2..2] ClkXEn: ClkX Output Enable: 0b0(0) */
    (0x00<<0) , /*      [1..0] Ediv: ClkE Divider: 0b00(0) */
    (0x01<<6) | /* 10H: [7..6] drvX: Bank3 (Xbuff) drive setting: 0b01(1) */
    (0x01<<4) | /*      [5..4] drvDE: Bank2 (ClkD, ClkE) drive setting: 0b01(1) */
    (0x01<<2) | /*      [3..2] drvC: Bank1 (ClkC) drive setting: 0b01(1) */
    (0x01<<0) , /*      [1..0] drvAB: Bank0 (ClkA, ClkB) drive setting: 0b01(1) */
    (0x00<<0) , /* 11H: [7..0] PLL2_QB: PLL2 8-bit Loadable Q-Counter: 0b00000000(0) */
    (0x00<<0) , /* 12H: [7..0] PLL2_PB[7:0]: PLL2 Lower 8 bits of 10-bit Loadable base P counter: 0b00000000(0) */
    (0x00<<7) | /* 13H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Pll2En: Enables PLL2 when high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL2_Pump: PLL2 Charge pump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL2_PO[0]: PLL2 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL2_PB[9:8]: PLL2 Upper 2 bits of 10-bit loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 14H: [7..0] PLL3_QB: PLL3 8-bit Loadable Q counter: 0b00000000(0) */
    (0x00<<0) , /* 15H: [7..0] PLL3_PB[7:0]: PLL3 Lower 8 bits of 10-bit Loadable base P counter: 0b00000000(0) */
    (0x00<<7) | /* 16H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Pll3En: Enables PLL3 when high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL3_Pump: PLL3 Charge pump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL3_PO[0]: PLL3 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL3_PB[9:8]: PLL3 Upper 2 bits  of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<2) | /* 17H: [7..2] xcap: Oscillator Load Capacitance Setting(6 MSB): 0b000000(0) */
    (0x01<<0) , /*      [1..0] xgm: Oscillator Inverter Drive Setting: 0b01(1) */
    (0x00<<7) | /* 18H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x00<<7) | /* 19H: [7..7] Reserved: Reserved: 0b0(0) */
    (0x00<<6) | /*      [6..6] Reserved: Reserved: 0b0(0) */
    (0x00<<5) | /*      [5..5] Reserved: Reserved: 0b0(0) */
    (0x00<<4) | /*      [4..4] Reserved: Reserved: 0b0(0) */
    (0x00<<3) | /*      [3..3] Reserved: Reserved: 0b0(0) */
    (0x00<<2) | /*      [2..2] Reserved: Reserved: 0b0(0) */
    (0x00<<1) | /*      [1..1] Reserved: Reserved: 0b0(0) */
    (0x00<<0) , /*      [0..0] Reserved: Reserved: 0b0(0) */
    (0x01<<7) | /* 1AH: [7..7] Reserved: Reserved: 0b1(1) */
    (0x69<<0) , /*      [6..0] Reserved: Reserved: 0b1101001(105) */
    (0x08<<0) , /* 1BH: [7..0] Reserved: Reserved: 0b00001000(8) */
};

const UINT8 CypressConfigDataUpperRegistersDisabled[] =
{
    (0x00<<0) , /* 40H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 41H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 42H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 43H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 44H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 45H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 46H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 47H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 48H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 49H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 4AH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 4BH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4CH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 4DH: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 4EH: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 4FH: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 50H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 51H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 52H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 53H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 54H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
    (0x00<<0) , /* 55H: [7..0] PLL1_QB: PLL1 8-bit Loadable Q Counter: 0b00000000(0) */
    (0x00<<0) , /* 56H: [7..0] PLL1_PB[7:0]: PLL1 Lower 8 bits of 10-bit Loadable baseP counter: 0b00000000(0) */
    (0x00<<7) | /* 57H: [7..7] DivSel: Dividers select for ClkA and ClkB: 0b0(0) */
    (0x00<<6) | /*      [6..6] PLL1En: Enables PLL1 and related outputs whdn high: 0b0(0) */
    (0x00<<3) | /*      [5..3] PLL1_Pump: PLL1 Chargepump Current Setting: 0b000(0) */
    (0x00<<2) | /*      [2..2] PLL1_PO[0]: PLL1 Offset Counter: 0b0(0) */
    (0x00<<0) , /*      [1..0] PLL1_PB[9:8]: PLL1 Upper 2 bits of 10-bit Loadable base P counter: 0b00(0) */
};


void CypressPLLInit(UINT32 InitOption)
{
    int BytesWritten;
    PUINT8 pLowerRegisterProgramData;
    PUINT8 pUpperRegisterProgramData;
    
    if (IS_FEMTOCELL_BOARD())
    {
        if (InitOption <= DEJITTER_INIT_IDLE)
        {
            uart_printf("Disabling ");
            pLowerRegisterProgramData = (PUINT8)CypressConfigDataLowerRegistersDisabled;
            pUpperRegisterProgramData = (PUINT8)CypressConfigDataUpperRegistersDisabled;                
        }
        else
        {
            uart_printf("Enabling ");
            pLowerRegisterProgramData = (PUINT8)CypressConfigDataLowerRegistersFemtocell;
            pUpperRegisterProgramData = (PUINT8)CypressConfigDataUpperRegistersFemtocell;                
        }
          
    }
    else
    {
        if (InitOption <= DEJITTER_INIT_IDLE)
        {
            pLowerRegisterProgramData = (PUINT8)CypressConfigDataLowerRegistersDisabled;
            pUpperRegisterProgramData = (PUINT8)CypressConfigDataUpperRegistersDisabled;                 
        }
        else if (InitOption == DEJITTER_INIT_RADIO)
        {
        	pLowerRegisterProgramData = (PUINT8)CypressConfigDataLowerRegisters40MHzInput;
            pUpperRegisterProgramData = (PUINT8)CypressConfigDataUpperRegisters40MHzInput;     
        }
        else
        {
        	pLowerRegisterProgramData = (PUINT8)CypressConfigDataLowerRegisters38_4MHzInput;
            pUpperRegisterProgramData = (PUINT8)CypressConfigDataUpperRegisters38_4MHzInput;     
        } 
    }
    

    BytesWritten =  I2CDrvWriteBytes(CYPRESS_I2C_ADDRESS,              // (0x69 << 1)
                                     CYPRESS_I2C_LOWER_REGISTER_BASE,  // 0x08
                                     pLowerRegisterProgramData,        // data
                                     CYPRESS_I2C_LOWER_REGISTER_COUNT  // length
                                    );
            
    BytesWritten += I2CDrvWriteBytes(CYPRESS_I2C_ADDRESS,             // (0x69 << 1)
                                     CYPRESS_I2C_UPPER_REGISTER_BASE, // 0x40
                                     pUpperRegisterProgramData,       // data
                                     CYPRESS_I2C_UPPER_REGISTER_COUNT // length
                                    );
        
    if (BytesWritten != (CYPRESS_I2C_LOWER_REGISTER_COUNT+CYPRESS_I2C_UPPER_REGISTER_COUNT))
    {
        uart_printf("CypressPLLInit: I2C write failure: Bytes Written:%u, Attempted:%u\n",
               BytesWritten,
               (CYPRESS_I2C_LOWER_REGISTER_COUNT+CYPRESS_I2C_UPPER_REGISTER_COUNT)
               );        
    }
}

//
// TI CDCE62005 Constants
//

//
// Mapping of ports
//
// INPUT:
//
// Pin     Function     Mapped to           Comments
//  45     PRI_REF+     CPRI0_RX_CLK_P      PRIMARY:   CPRI 0 RX CLOCK (153.6)
//  46     PRI_REF-     CPRI0_RX_CLK_M
//  47     SEC_REF+     CPRI1_RX_CLK_P      SECONDARY: CPRI 1 RX CLOCK (153.6)
//  48     SEC_REF-     CPRI1_RX_CLK_M
//  43     AUX_IN       TSU_NTG_CLOCK       AUX:       CLOCK OUT FROM TURNER NTG (12.8) (AJ13 TSU_NTG_CLKOUT)

// OUTPUT
// Pin     Function     Mapped to           Comments               Rate
//  27     U0P          CPRI0_CLK2x_P       0: CPRI 2X CLOCK       (307.2 MHz)
//  28     UON          CPRI0_CLK2x_M
//  19     U1P          CPRI1_CLK2x_P       1: CPRI 2X CLOCK       (307.2 MHz)
//  20     U1N          CPRI1_CLK2x_M
//  16     U2P          CPRI_FPGA_CLK_P     2: CPRI FPGA CLOCK     (153.6 MHz)
//  17     U2N          CPRI_FPGA_CLK_M
//   9     U3P          RADCON_REFCLK_P     3: RADIO CLOCK         ( 38.4 MHz)
//  10     U3N          RADCON_REFCLK_M
//   6  U4P         1588_CPRI_REF_CLK_P     4: 1588 CPRI REF CLOCK (153.6 MHz)
//   7  U4N         1588_CPRI_REF_CLK_N
//  13  AUX_OUT     CLEAN_CPRI_CLK
//  

// NOTE: Careful! TI spec has all grouped bit constants backwards reversed
//       (reflected) in relation to how they are represented in software
//       Fortunately, this apparently does not apply to number fields

// NOTE: Careful again! Registers 0-4 in general have the same values
//       except for the 2 least signficant bits which are different
//       in the various registers 0 through 4.

// TI register 0 specific constants
#define DEJ_OUT_PRI_REF_3_STATE    (0<<0)  /* (00 in spec)*/
#define DEJ_OUT_PRI_REF_DIV_1      (2<<0)  /* (01 in spec)*/
#define DEJ_OUT_PRI_REF_DIV_2      (1<<0)  /* (10 in spec)*/
#define DEJ_OUT_PRI_REF_RSVD       (3<<0)  /* (11 in spec)*/

// TI register 0 specific constants
#define DEJ_OUT_SEC_REF_3_STATE    (0<<0)  /* (00 in spec)*/
#define DEJ_OUT_SEC_REF_DIV_1      (2<<0)  /* (01 in spec)*/
#define DEJ_OUT_SEC_REF_DIV_2      (1<<0)  /* (10 in spec)*/
#define DEJ_OUT_SEC_REF_RSVD       (3<<0)  /* (11 in spec)*/

// TI register 2 specific constants
#define DEJ_REG_2_REF_DIV_BIT0(b)  (b<<0)
#define DEJ_REG_2_REF_DIV_BIT1(b)  (b<<1)

// TI register 3 specific constants
#define DEJ_REG_3_REF_DIV_BIT_2(b) (1<<0) /* Reference divider bit 2 */
#define DEJ_REG_3_RESERVED         (0<<1) /* Reserved, TI does not specify value, using 0 */

// TI register 4 specific constants
#define DEJ_REG_4_RESERVED         (1<<0) /* Must always be 1 */
#define DEJ_REG_4_ATEST_NORMAL     (0<<1) /* Normal operation */
#define DEJ_REG_4_ATEST_SYNC_TEST  (1<<1) /* See TI spec */

// TI register 0-4 common constants

#define DEJ_OUT_RSVD_TEST_MODE     (0<<2)

#define DEJ_OUT_MUX_PRI_IN         (0<<4) /* (00 in spec)*/
#define DEJ_OUT_MUX_SEC_IN         (2<<4) /* (01 in spec)*/
#define DEJ_OUT_MUX_SMART_MUX      (1<<4) /* (10 in spec)*/
#define DEJ_OUT_MUX_VCO_CORE       (3<<4) /* (11 in spec)*/ /* a.k.a Frequency Synthesizer */

#define DEJ_OUT_PHASE_ADJ(phase)   ((phase  & 0x7F /*0b1111111*/ )<<6)

#define DEJ_OUT_DIV(divisor)       ((divisor& 0x7F /*0b1111111*/ )<<13)

#define DEJ_OUT_DIV_ENABLED        (1<<20)
#define DEJ_OUT_DIV_DISABLED       (0<<20)

#define DEJ_OUT_LVPECL             ( 0x20 /* 0b100000 */ <<22)
#define DEJ_OUT_LVDS               ( 0x3A /* 0b111010 */ <<22)
#define DEJ_OUT_DISABLED           ( 0x1A /* 0b011010 */ <<22)

#define DEJ_OUT_LVCMOS             (0<<22)
#define DEJ_OUT_LVCMOS_P_ACTIVE    (0<<22) // (00 in spec)
#define DEJ_OUT_LVCMOS_P_INVERTING (2<<22) // (01 in spec)
#define DEJ_OUT_LVCMOS_P_LOW       (1<<22) // (10 in spec)
#define DEJ_OUT_LVCMOS_P_3_STATE   (3<<22) // (11 in spec)
#define DEJ_OUT_LVCMOS_N_ACTIVE    (0<<24) // (00 in spec)
#define DEJ_OUT_LVCMOS_N_INVERTING (2<<24) // (01 in spec)
#define DEJ_OUT_LVCMOS_N_LOW       (1<<24) // (10 in spec)
#define DEJ_OUT_LVCMOS_N_3_STATE   (3<<24) // (11 in spec)

//
// Register 5 values & macros
//
#define DEJ_INPUT_DIVIDER(x)       ((x-1)<<14)

//
// Register 6 values
//
#define DEJ_VCO1_LOW_RANGE         (0<<0)
#define DEJ_VCO1_HIGH_RANGE        (1<<0)

// Settings for "P" (see TI document equations)
#define DEJ_PRESCALER_DIV_5        (0<<1)
#define DEJ_PRESCALER_DIV_4        (2<<1)
#define DEJ_PRESCALER_DIV_3        (1<<1)
#define DEJ_PRESCALER_DIV_2        (3<<1)

// Settings for "F" (see TI document equations)
#define DEJ_FEEDBACK_DIV_8         (0x00<<3)
#define DEJ_FEEDBACK_DIV_12        (0x01<<3)
#define DEJ_FEEDBACK_DIV_16        (0x02<<3)
#define DEJ_FEEDBACK_DIV_20        (0x03<<3)
#define DEJ_FEEDBACK_DIV_24        (0x05<<3)
#define DEJ_FEEDBACK_DIV_32        (0x06<<3)
#define DEJ_FEEDBACK_DIV_36        (0x09<<3)
#define DEJ_FEEDBACK_DIV_40        (0x07<<3)
#define DEJ_FEEDBACK_DIV_48        (0x0A<<3)
#define DEJ_FEEDBACK_DIV_56        (0x18<<3)
#define DEJ_FEEDBACK_DIV_60        (0x0B<<3)
#define DEJ_FEEDBACK_DIV_64        (0x0E<<3)
#define DEJ_FEEDBACK_DIV_72        (0x15<<3)
#define DEJ_FEEDBACK_DIV_80        (0x0F<<3)
#define DEJ_FEEDBACK_DIV_84        (0x19<<3)
#define DEJ_FEEDBACK_DIV_96        (0x16<<3)
#define DEJ_FEEDBACK_DIV_100       (0x13<<3)
#define DEJ_FEEDBACK_DIV_108       (0x49<<3)
#define DEJ_FEEDBACK_DIV_112       (0x1A<<3)
#define DEJ_FEEDBACK_DIV_120       (0x17<<3)
#define DEJ_FEEDBACK_DIV_128       (0x1E<<3)
#define DEJ_FEEDBACK_DIV_140       (0x1B<<3)
#define DEJ_FEEDBACK_DIV_144       (0x35<<3)
#define DEJ_FEEDBACK_DIV_160       (0x1F<<3)
#define DEJ_FEEDBACK_DIV_168       (0x39<<3)
#define DEJ_FEEDBACK_DIV_180       (0x4B<<3)
#define DEJ_FEEDBACK_DIV_192       (0x36<<3)
#define DEJ_FEEDBACK_DIV_200       (0x33<<3)
#define DEJ_FEEDBACK_DIV_216       (0x55<<3)
#define DEJ_FEEDBACK_DIV_224       (0x3A<<3)
#define DEJ_FEEDBACK_DIV_240       (0x37<<3)
#define DEJ_FEEDBACK_DIV_252       (0x59<<3)
#define DEJ_FEEDBACK_DIV_280       (0x3B<<3)
#define DEJ_FEEDBACK_DIV_288       (0x56<<3)
#define DEJ_FEEDBACK_DIV_300       (0x53<<3)
#define DEJ_FEEDBACK_DIV_320       (0x3F<<3)
#define DEJ_FEEDBACK_DIV_336       (0x5A<<3)
#define DEJ_FEEDBACK_DIV_360       (0x57<<3)
#define DEJ_FEEDBACK_DIV_384       (0x5E<<3)
#define DEJ_FEEDBACK_DIV_400       (0x73<<3)
#define DEJ_FEEDBACK_DIV_420       (0x5B<<3)
#define DEJ_FEEDBACK_DIV_432       (0xB5<<3)
#define DEJ_FEEDBACK_DIV_448       (0x7A<<3)
#define DEJ_FEEDBACK_DIV_480       (0x5F<<3)
#define DEJ_FEEDBACK_DIV_500       (0x93<<3)
#define DEJ_FEEDBACK_DIV_504       (0xB9<<3)
#define DEJ_FEEDBACK_DIV_512       (0x7E<<3)
#define DEJ_FEEDBACK_DIV_560       (0x7B<<3)
#define DEJ_FEEDBACK_DIV_576       (0xB6<<3)
#define DEJ_FEEDBACK_DIV_588       (0xB9<<3)
#define DEJ_FEEDBACK_DIV_600       (0x97<<3)
#define DEJ_FEEDBACK_DIV_640       (0x7F<<3)
#define DEJ_FEEDBACK_DIV_672       (0xBA<<3)

// For other feedback values, see TI spec


// Register 7 Loop Filter Values

// For loop filter, various values of C1, C2, C3 can be obtained by adding values
// As selecting a value is by setting the bit TRUE (1)

// For loop filter, various values of R2 and R3 are obtained for each intertnal resistor
// when the bit is set to FALSE (0).  For that reason, to make it simpler and 
// more obvious in the code, all possible values are defined 
//
// C1, C3, R2, and R3 can be external if the external loop filter bit in register 6 is set to TRUE (1)
// If that bit is set, then the register values for those external loop filter elements are ignored

#define DEJ_LOOP_FILTER_C2_0_PF         (0<< 0)
#define DEJ_LOOP_FILTER_C2_12_5_PF      (1<< 0)
#define DEJ_LOOP_FILTER_C2_25_PF        (1<< 1)
#define DEJ_LOOP_FILTER_C2_37_5_PF      (DEJ_LOOP_FILTER_C2_25_PF | DEJ_LOOP_FILTER_C2_12_5_PF)   
#define DEJ_LOOP_FILTER_C2_87_PF        (1<< 2)
#define DEJ_LOOP_FILTER_C2_99_5_PF      (DEJ_LOOP_FILTER_C2_87_PF | DEJ_LOOP_FILTER_C2_12_5_PF)   
#define DEJ_LOOP_FILTER_C2_112_PF       (DEJ_LOOP_FILTER_C2_87_PF | DEJ_LOOP_FILTER_C2_25_PF)   
#define DEJ_LOOP_FILTER_C2_124_5_PF     (DEJ_LOOP_FILTER_C2_87_PF | DEJ_LOOP_FILTER_C2_37_5_PF)   
#define DEJ_LOOP_FILTER_C2_123_PF       (1<< 3)
#define DEJ_LOOP_FILTER_C2_135_5_PF     (DEJ_LOOP_FILTER_C2_123_PF | DEJ_LOOP_FILTER_C2_12_5_PF)   
#define DEJ_LOOP_FILTER_C2_145_PF       (DEJ_LOOP_FILTER_C2_123_PF | DEJ_LOOP_FILTER_C2_25_PF)   
#define DEJ_LOOP_FILTER_C2_160_5_PF     (DEJ_LOOP_FILTER_C2_123_PF | DEJ_LOOP_FILTER_C2_37_5_PF)
#define DEJ_LOOP_FILTER_C2_210_PF       (DEJ_LOOP_FILTER_C2_123_PF | DEJ_LOOP_FILTER_C2_87_PF)   
#define DEJ_LOOP_FILTER_C2_222_5_PF     (DEJ_LOOP_FILTER_C2_123_PF | DEJ_LOOP_FILTER_C2_99_5_PF)   
#define DEJ_LOOP_FILTER_C2_235_PF       (DEJ_LOOP_FILTER_C2_123_PF | DEJ_LOOP_FILTER_C2_112_PF)
#define DEJ_LOOP_FILTER_C2_247_5_PF     (DEJ_LOOP_FILTER_C2_123_PF | DEJ_LOOP_FILTER_C2_124_5_PF)
#define DEJ_LOOP_FILTER_C2_226_PF  	    (1<< 4)
#define DEJ_LOOP_FILTER_C2_238_5_PF     (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_12_5_PF)   
#define DEJ_LOOP_FILTER_C2_251_PF       (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_25_PF)   
#define DEJ_LOOP_FILTER_C2_263_5_PF     (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_37_5_PF)
#define DEJ_LOOP_FILTER_C2_313_PF       (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_87_PF)   
#define DEJ_LOOP_FILTER_C2_325_5_PF     (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_99_5_PF)   
#define DEJ_LOOP_FILTER_C2_338_PF       (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_112_PF)
#define DEJ_LOOP_FILTER_C2_350_5_PF     (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_124_5_PF)   
#define DEJ_LOOP_FILTER_C2_349_PF       (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_123_PF)   
#define DEJ_LOOP_FILTER_C2_361_5_PF     (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_135_5_PF)
#define DEJ_LOOP_FILTER_C2_371_PF       (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_145_PF)   
#define DEJ_LOOP_FILTER_C2_386_5_PF     (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_160_5_PF)   
#define DEJ_LOOP_FILTER_C2_436_PF       (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_210_PF)
#define DEJ_LOOP_FILTER_C2_448_5_PF     (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_222_5_PF)   
#define DEJ_LOOP_FILTER_C2_461_PF       (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_235_PF)
#define DEJ_LOOP_FILTER_C2_473_5_PF     (DEJ_LOOP_FILTER_C2_226_PF | DEJ_LOOP_FILTER_C2_247_5_PF)

#define DEJ_LOOP_FILTER_C2_MAX          DEJ_LOOP_FILTER_C2_473_5_PF

//                                                  //
//                                                  //   +-----   56.4K if bit false
//                                                  //   |+-----  38.2K if bit false
//                                                  //   ||+----- 20K   if bit false
//                                                  //   |||+---- 9K    if bit false
//                                                  //   ||||+--- 4K    if bit false
//                                                  //   |||||
//                                                  //   VVVVV
#define DEJ_LOOP_FILTER_R2_0_K_OHM      (0x1F << 5) /**< 0b11111 0 */
#define DEJ_LOOP_FILTER_R2_4_K_OHM      (0x1E << 5) /**< 0b11110 4K  */
#define DEJ_LOOP_FILTER_R2_9_K_OHM      (0x1D << 5) /**< 0b11101 9K  */
#define DEJ_LOOP_FILTER_R2_13_K_OHM     (0x1C << 5) /**< 0b11100 9K + 4K */
#define DEJ_LOOP_FILTER_R2_20_K_OHM     (0x1B << 5) /**< 0b11011 20K */
#define DEJ_LOOP_FILTER_R2_24_K_OHM     (0x1A << 5) /**< 0b11010 20K + 4K */
#define DEJ_LOOP_FILTER_R2_29_K_OHM     (0x19 << 5) /**< 0b11001 20K + 9K */
#define DEJ_LOOP_FILTER_R2_33_K_OHM     (0x18 << 5) /**< 0b11000 20K + 9K + 4K */
#define DEJ_LOOP_FILTER_R2_38_2_K_OHM   (0x17 << 5) /**< 0b10111 38.2K */
#define DEJ_LOOP_FILTER_R2_42_2_K_OHM   (0x16 << 5) /**< 0b10110 38.2K + 4K */
#define DEJ_LOOP_FILTER_R2_47_2_K_OHM   (0x15 << 5) /**< 0b10101 38.2K + 9K */
#define DEJ_LOOP_FILTER_R2_51_2_K_OHM   (0x14 << 5) /**< 0b10100 38.2K + 9K + 4K */
#define DEJ_LOOP_FILTER_R2_56_4_K_OHM   (0x0F << 5) /**< 0b01111 56.4K */
#define DEJ_LOOP_FILTER_R2_58_2_K_OHM   (0x13 << 5) /**< 0b10011 38.2K + 20K */
#define DEJ_LOOP_FILTER_R2_60_4_K_OHM   (0x0E << 5) /**< 0b01110 56.4K + 4K  */
#define DEJ_LOOP_FILTER_R2_62_2_K_OHM   (0x12 << 5) /**< 0b10010 38.2K + 20K + 4K */
#define DEJ_LOOP_FILTER_R2_65_4_K_OHM   (0x0D << 5) /**< 0b01101 56.4K + 9K  */
#define DEJ_LOOP_FILTER_R2_67_2_K_OHM   (0x11 << 5) /**< 0b10001 38.2K + 20K + 9K */
#define DEJ_LOOP_FILTER_R2_69_4_K_OHM   (0x0C << 5) /**< 0b01100 56.4K + 9K + 4K */
#define DEJ_LOOP_FILTER_R2_71_2_K_OHM   (0x10 << 5) /**< 0b10000 38.2K + 20K + 9K + 4K */
#define DEJ_LOOP_FILTER_R2_76_4_K_OHM   (0x0B << 5) /**< 0b01011 56.4K + 20K */
#define DEJ_LOOP_FILTER_R2_80_4_K_OHM   (0x0A << 5) /**< 0b01010 56.4K + 20K + 4K */
#define DEJ_LOOP_FILTER_R2_85_4_K_OHM   (0x09 << 5) /**< 0b01001 56.4K + 20K + 9K */
#define DEJ_LOOP_FILTER_R2_89_4_K_OHM   (0x08 << 5) /**< 0b01000 56.4K + 20K + 9K + 4K */
#define DEJ_LOOP_FILTER_R2_94_6_K_OHM   (0x07 << 5) /**< 0b00111 56.4K + 38.2K */
#define DEJ_LOOP_FILTER_R2_98_6_K_OHM   (0x06 << 5) /**< 0b00110 56.4K + 38.2K + 4K */
#define DEJ_LOOP_FILTER_R2_103_6_K_OHM  (0x05 << 5) /**< 0b00101 56.4K + 38.2K + 9K */
#define DEJ_LOOP_FILTER_R2_107_6_K_OHM  (0x04 << 5) /**< 0b00100 56.4K + 38.2K + 9K + 4K */
#define DEJ_LOOP_FILTER_R2_114_6_K_OHM  (0x03 << 5) /**< 0b00011 56.4K + 38.2K + 20K */
#define DEJ_LOOP_FILTER_R2_118_6_K_OHM  (0x02 << 5) /**< 0b00010 56.4K + 38.2K + 20K + 4K */
#define DEJ_LOOP_FILTER_R2_123_6_K_OHM  (0x01 << 5) /**< 0b00001 56.4K + 38.2K + 20K + 9K */
#define DEJ_LOOP_FILTER_R2_127_6_K_OHM  (0x00 << 5) /**< 0b00000 56.4K + 38.2K + 20K + 9K + 4K */

#define DEJ_LOOP_FILTER_R2_MAX          DEJ_LOOP_FILTER_R2_127_6_K_OHM

#define DEJ_LOOP_FILTER_C1_0_PF         (0<<10)
#define DEJ_LOOP_FILTER_C1_1_5_PF       (1<<10)
#define DEJ_LOOP_FILTER_C1_6_5_PF       (1<<11)
#define DEJ_LOOP_FILTER_C1_8_PF         (DEJ_LOOP_FILTER_C1_6_5_PF | DEJ_LOOP_FILTER_C1_1_5_PF)   
#define DEJ_LOOP_FILTER_C1_10_PF        (1<<12)
#define DEJ_LOOP_FILTER_C1_11_5_PF      (DEJ_LOOP_FILTER_C1_10_PF  | DEJ_LOOP_FILTER_C1_1_5_PF)   
#define DEJ_LOOP_FILTER_C1_16_5_PF      (DEJ_LOOP_FILTER_C1_10_PF  | DEJ_LOOP_FILTER_C1_6_5_PF)   
#define DEJ_LOOP_FILTER_C1_18_PF        (DEJ_LOOP_FILTER_C1_10_PF  | DEJ_LOOP_FILTER_C1_8_PF)  
#define DEJ_LOOP_FILTER_C1_21_5_PF      (1<<13)
#define DEJ_LOOP_FILTER_C1_23_PF        (DEJ_LOOP_FILTER_C1_21_5_PF  | DEJ_LOOP_FILTER_C1_1_5_PF)   
#define DEJ_LOOP_FILTER_C1_28_PF        (DEJ_LOOP_FILTER_C1_21_5_PF  | DEJ_LOOP_FILTER_C1_6_5_PF)   
#define DEJ_LOOP_FILTER_C1_29_5_PF      (DEJ_LOOP_FILTER_C1_21_5_PF  | DEJ_LOOP_FILTER_C1_8_PF)  
#define DEJ_LOOP_FILTER_C1_31_5_PF      (DEJ_LOOP_FILTER_C1_21_5_PF  | DEJ_LOOP_FILTER_C1_10_PF)   
#define DEJ_LOOP_FILTER_C1_33_PF        (DEJ_LOOP_FILTER_C1_21_5_PF  | DEJ_LOOP_FILTER_C1_11_5_PF)   
#define DEJ_LOOP_FILTER_C1_38_PF        (DEJ_LOOP_FILTER_C1_21_5_PF  | DEJ_LOOP_FILTER_C1_16_5_PF)  
#define DEJ_LOOP_FILTER_C1_39_5_PF      (DEJ_LOOP_FILTER_C1_21_5_PF  | DEJ_LOOP_FILTER_C1_18_PF)  
#define DEJ_LOOP_FILTER_C1_37_5_PF      (1<<14)
#define DEJ_LOOP_FILTER_C1_39_PF        (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_1_5_PF)   
#define DEJ_LOOP_FILTER_C1_44_PF        (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_6_5_PF)   
#define DEJ_LOOP_FILTER_C1_45_5_PF      (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_8_PF)  
#define DEJ_LOOP_FILTER_C1_47_5_PF      (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_10_PF)   
#define DEJ_LOOP_FILTER_C1_49_PF        (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_11_5_PF)   
#define DEJ_LOOP_FILTER_C1_54_PF        (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_16_5_PF)  
#define DEJ_LOOP_FILTER_C1_55_5_PF      (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_18_PF)  
#define DEJ_LOOP_FILTER_C1_59_PF        (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_21_5_PF)
#define DEJ_LOOP_FILTER_C1_61_PF        (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_23_PF)   
#define DEJ_LOOP_FILTER_C1_65_5_PF      (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_28_PF)   
#define DEJ_LOOP_FILTER_C1_67_PF        (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_29_5_PF)  
#define DEJ_LOOP_FILTER_C1_69_PF        (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_31_5_PF)   
#define DEJ_LOOP_FILTER_C1_70_5_PF      (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_33_PF)   
#define DEJ_LOOP_FILTER_C1_75_5_PF      (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_38_PF)  
#define DEJ_LOOP_FILTER_C1_77_PF        (DEJ_LOOP_FILTER_C1_37_5_PF  | DEJ_LOOP_FILTER_C1_39_5_PF)  

#define DEJ_LOOP_FILTER_C1_MAX          DEJ_LOOP_FILTER_C1_77_PF

#define DEJ_LOOP_FILTER_C3_0_PF         (0<<15)
#define DEJ_LOOP_FILTER_C3_2_5_PF       (1<<15)
#define DEJ_LOOP_FILTER_C3_5_5_PF       (1<<16)
#define DEJ_LOOP_FILTER_C3_8_PF         (DEJ_LOOP_FILTER_C3_5_5_PF | DEJ_LOOP_FILTER_C3_2_5_PF)   
#define DEJ_LOOP_FILTER_C3_19_5_PF      (1<<17)
#define DEJ_LOOP_FILTER_C3_22_PF        (DEJ_LOOP_FILTER_C3_19_5_PF | DEJ_LOOP_FILTER_C3_2_5_PF)
#define DEJ_LOOP_FILTER_C3_25_PF        (DEJ_LOOP_FILTER_C3_19_5_PF | DEJ_LOOP_FILTER_C3_5_5_PF)
#define DEJ_LOOP_FILTER_C3_27_5_PF      (DEJ_LOOP_FILTER_C3_19_5_PF | DEJ_LOOP_FILTER_C3_8_PF)
#define DEJ_LOOP_FILTER_C3_85_PF        (1<<18)
#define DEJ_LOOP_FILTER_C3_87_5_PF      (DEJ_LOOP_FILTER_C3_85_PF | DEJ_LOOP_FILTER_C3_2_5_PF)
#define DEJ_LOOP_FILTER_C3_90_5_PF      (DEJ_LOOP_FILTER_C3_85_PF | DEJ_LOOP_FILTER_C3_5_5_PF)
#define DEJ_LOOP_FILTER_C3_93_PF        (DEJ_LOOP_FILTER_C3_85_PF | DEJ_LOOP_FILTER_C3_8_PF)
#define DEJ_LOOP_FILTER_C3_102_5_PF     (DEJ_LOOP_FILTER_C3_85_PF | DEJ_LOOP_FILTER_C3_19_5_PF)
#define DEJ_LOOP_FILTER_C3_107_PF       (DEJ_LOOP_FILTER_C3_85_PF | DEJ_LOOP_FILTER_C3_22_PF)
#define DEJ_LOOP_FILTER_C3_110_PF       (DEJ_LOOP_FILTER_C3_85_PF | DEJ_LOOP_FILTER_C3_25_PF)
#define DEJ_LOOP_FILTER_C3_112_5_PF     (DEJ_LOOP_FILTER_C3_85_PF | DEJ_LOOP_FILTER_C3_27_5_PF)

#define DEJ_LOOP_FILTER_C3_MAX          DEJ_LOOP_FILTER_C3_112_5_PF

#define DEJ_LOOP_FILTER_R3_5_K_OHM      (3 << 19)  /**< 0b11 */
#define DEJ_LOOP_FILTER_R3_10_K_OHM     (2 << 19)  /**< 0b10 */
#define DEJ_LOOP_FILTER_R3_15_K_OHM     (1 << 19)  /**< 0b01 */
#define DEJ_LOOP_FILTER_R3_20_K_OHM     (0 << 19)  /**< 0b00 */

#define DEJ_LOOP_FILTER_R3_MAX          DEJ_LOOP_FILTER_R3_20_K_OHM

//
// Per TI spec, to force a manual calibration of the
// VCO, you must first set encalibration mode
// to manual (if not already set to manual at power up)
// then write a 0 followed by a 1 to the encalibration
// command bit
//
#define DEJ_ENCAL_COMMAND_LOW      (0<<22)
#define DEJ_ENCAL_COMMAND_HIGH     (0<<22)

#define DEJ_ENCAL_MODE_STARTUP     (0<<27)
#define DEJ_ENCAL_MODE_MANUAL      (1<<27)

// Register 8 values
#define DEJ_CALIBRATION_WORD_MASK  (0x3F)
#define DEJ_SLEEP_MODE_OFF         (1<<7)

#define DEJ_FORCE_SYNC_STATE       (0<<8)
#define DEJ_EXIT_SYNC_STATE        (1<<8)

#define DEJ_SYNTH_SOURCE_MASK      (7<<25)
#define DEJ_SYNTH_PRI_INPUT        (1<<25)
#define DEJ_SYNTH_SEC_INPUT        (1<<26)
#define DEJ_SYNTH_AUX_INPUT        (1<<27)

#define AD9548_READ_CMD  			    0x80
#define AD9548_WRITE_CMD                0x00
#define AD9548_XFER_ONE_BYTE_CMD        0x00
#define AD9548_XFER_TWO_BYTES_CMD       0x20
#define AD9548_XFER_THREE_BYTES_CMD     0x40
#define AD9548_XFER_STREAM_MODE_CMD     0x60


#if 0
// Factory configuration from TI spec
// Primary and Secondary are LVPECL AC termination
// AUX input enabled
// SMART MUX set to auto select between Primary, Secondary, AUX
// Reference is 25 MHz
// Dividers set to run the VCO at 1875 MHz
const UINT32 DejitterFactoryConfig[8] =
{
    { 0x08184032 }, // 0: LEVPECL 156.25 MHz
    { 0x08184030 }, // 1: LEVPECL 156.25 MHz
    { 0x08186030 }, // 2: LEVPECL 125.00 MHz
    { 0x0EB86030 }, // 3: LVDS    125.00 MHz
    { 0x00186031 }, // 4: LVCMOS  125.00 MHz
    { 0x0101C0BE }, // 5: Input divider:8, PRI then SEC then AUX, REF_SEL pin ignored
    { 0x004BE19A }, // 6: Feedback divider:200, Prescaler:3, VCO low range, Bypass the bypass divider, 2mA charge pump
    { 0x0BD0037F }, // 7: Loop filter C2:473.5pF, R2:20kOhm, C1:0pF, C3:0pF, R3:10kOhm; Long Delay 1&2     
};    
#endif

#if 0
// Defaults based on always AUX input @ 30.72 MHz, various outputs
const UINT32 DejitterDefaultConfig[8] =
{
    { 0x0EB80032 }, // 0: LVDS 307.2 MHz, Div by 2,  PRI input tri stated
    { 0x0EB80032 }, // 1: LVDS 307.2 MHz, Div by 2,  SEC input tri stated
    { 0x0EB84030 }, // 2: LVDS 153.6 MHz, Div by 4,  PRI/SEC divide by 5 -> 30.72 (same as AUX input)
    { 0x0EB0C031 }, // 3: LVDS  38.4 MHz, Div by 16, PRI/SEC divide by 5 -> 30.72 (same as AUX input)
    { 0x0EB84031 }, // 4: LVDS 153.6 MHz, Div by 4
    { 0x010040B0 }, // 5: Input div by 2, AUX only, EEPROM clk settings, LVDS input buffer, Medium lock window, PLL lock on first detect
    { 0x034BF03A }, // 6: Feedback div by 40, Prescaler:3, VCO low range, Bypass divider bypass, 2mA charge pump, AUX enabled, source OUT 3, internal loop filter
    { 0x0BD0037F }, // 7: Loop filter C2:473.5pF, R2:20kOhm, C1:0pF, C3:0pF, R3:10kOhm; Long Delay 1&2     
};
#endif

// AKB input 12.8 MHz values
// TI setup for: R:1, I:2, O: 2(for 307.2), 4(for 153.6) ,16(for 38.4) P:3 F:96

// CPRI configuration for T4K EVM board 
// Primary and Secondary are LVDS, but not used (forced to AUX input as reference)
// AUX input enabled
// SMART MUX set to always take AUX as input
// VCO source as Smart Mux
// AUX input Reference is 12.8 MHz
// AUX output generates 38.4 MHz to feed into Cypress CY22393 PLL (for other ports, see below)
// Dividers set to run the VCO at 1843.2 MHz
//#define DEJ_LOOP_FACTORY_DEFAULT

/**
 * @brief CPRI configuration for T4K EVM board, CPRI mode
 *
 * @details
 *<pre>
 * Primary and Secondary are LVDS, but not used (forced to AUX input as reference)
 * AUX input enabled
 * SMART MUX set to always take AUX as input
 * VCO source as Smart Mux
 * AUX input Reference is 12.8 MHz
 * AUX output generates 38.4 MHz to feed into Cypress CY22393 PLL (for other ports, see below)
 * Dividers set to run the VCO at 1843.2 MHz
 * </pre>
 */
static const UINT32 DejitterCpriConfig[8] =
{
    { 0x0EB80032 }, // 0: LVDS 307.2 MHz, Output Div by 2,  PRI input divide by 1
    { 0x0EB80032 }, // 1: LVDS 307.2 MHz, Output Div by 2,  SEC input divide by 1
    { 0x0EB84031 }, // 2: LVDS 153.6 MHz, Output Div by 4,  PRI/SEC input divide by 6(with /2) -> 12.8 (same as AUX input)
    { 0x0EB0C031 }, // 3: LVDS  38.4 MHz, Output Div by 16, PRI/SEC input divide by 6(with /2) -> 12.8 (same as AUX input)
    { 0x0EB84031 }, // 4: LVDS 153.6 MHz, Div by 4
    { 0x010040B0 }, // 5: Input div by 2, AUX only, EEPROM clk settings, LVDS input buffer, Medium lock window, PLL lock on first detect
//  { 0x034BF0B2 }, // 6: Feedback div by 96, Prescaler:3, VCO low range, Bypass divider bypass, 2mA charge pump, AUX enabled, source OUT 3, internal loop filter
    { 0x0340F0B2 }, // 6: Feedback div by 96, Prescaler:3, VCO low range, Bypass divider bypass, 50uA charge pump, AUX enabled, source OUT 3, internal loop filter
    { //0x0BD0037F
      ( 0x0BC00000                  // 7: Factory default upper bits 27-21
      | DEJ_LOOP_FILTER_C2_MAX
      | DEJ_LOOP_FILTER_R2_4_K_OHM
      | DEJ_LOOP_FILTER_C1_MAX
      | DEJ_LOOP_FILTER_C3_MAX
      | DEJ_LOOP_FILTER_R3_10_K_OHM
      )
    }, 
};

// AKB input 40 MHz values to 10 MHz aux out (for Radio testing)
// TI setup for: R:1, I:4, O: 2(for 300.0), 4(for 150.0) ,60(for 38.4) P:3 F:96

/**
 * @brief Radio configuration to for T4K EVM board, radio mode
 *
 * @details
 *<pre>
 * Primary and Secondary are LVDS, but not used (forced to AUX input as reference)
 * AUX input enabled
 * SMART MUX set to always take AUX as input
 * VCO source as Smart Mux
 * AUX input Reference is 40 MHz from radio chipset
 * AUX output generates 10 MHz to feed into ...
 * Dividers set to run the VCO at 1800.0 MHz
 * </pre>
 */
static const UINT32 DejitterRadioConfig[8] =
{
    { 0x0EB80032 }, // 0: LVDS 307.2 MHz, Divisor enabled, Output Div by 2,  PRI input divide by 1
    { 0x0EB80032 }, // 1: LVDS 307.2 MHz, Divisor enabled, Output Div by 2,  SEC input divide by 1
    { 0x0EB84031 }, // 2: LVDS 153.6 MHz, Divisor enabled, Output Div by 4,  PRI/SEC input divide by 6(with /2)
    { 0x0EB2E031 }, // 3: LVDS  10.0 MHz, Output Div by 60, PRI/SEC input divide by 6(with /2) -> 12.8 (same as AUX input)
    { 0x0EB84031 }, // 4: LVDS 150/0 MHz, Div by 4
    { 0x0100C0B0 }, // 5: Input div by 4, AUX only, EEPROM clk settings, LVDS input buffer, Medium lock window, PLL lock on first detect
//  { 0x034B300A }, // 6: Feedback div by 12, Prescaler:3, VCO low range, Bypass divider 5, 2mA charge pump, AUX enabled, source OUT 3, internal loop filter
    { 0x0340300A }, // 6: Feedback div by 12, Prescaler:3, VCO low range, Bypass divider 5, 50uA charge pump, AUX enabled, source OUT 3, internal loop filter
    { //0x0BD0037F
      ( 0x0BC00000                  // 7: Factory default upper bits 27-21
      // Values for lower bandwidth filter to provide better dejitter
      // characteristics:
      | DEJ_LOOP_FILTER_C2_MAX
      | DEJ_LOOP_FILTER_R2_4_K_OHM
      | DEJ_LOOP_FILTER_C1_MAX
      | DEJ_LOOP_FILTER_C3_MAX
      | DEJ_LOOP_FILTER_R3_10_K_OHM
      )
    }
};

/**  @brief TI device EEPROM/Idle settings
 * @details
 * <pre>
 * Primary and Secondary are LVDS, but not used (forced to AUX input as reference)
 * AUX input enabled
 * SMART MUX set to always take AUX as input
 * VCO source as Smart Mux
 * AUX input Reference is 40 MHz from radio chipset
 * AUX output generates 10 MHz to feed into ...
 * Dividers set to run the VCO at 1800.0 MHz
* </pre>
*/

static const UINT32 DejitterIdleConfig[8] =
{
    { 0x06A80032 }, // 0: Output disabled, Divisor disabled, Output Div by 2,  PRI input divide by 1
    { 0x06A80032 }, // 1: Output disabled, Divisor disabled, Output Div by 2,  SEC input divide by 1
    { 0x06A84031 }, // 2: Output disabled, Divisor disabled, Output Div by 4,  PRI/SEC input divide by 6(with /2) -> 12.8 (same as AUX input)
    { 0x06A2E031 }, // 3: Output disabled, Divisor disabled, PRI/SEC input divide by 6(with /2) -> 12.8 (same as AUX input)
    { 0x06A84031 }, // 4: Output disabled, Divisor disabled, Output Div by 4
    { 0x0100C0B0 }, // 5: Input div by 4, AUX only, EEPROM clk settings, LVDS input buffer, Medium lock window, PLL lock on first detect
//  { 0x034B300A }, // 6: Feedback div by 12, Prescaler:3, VCO low range, Bypass divider 5, 2mA charge pump, AUX enabled, source OUT 3, internal loop filter
    { 0x0340300A }, // 6: Feedback div by 12, Prescaler:3, VCO low range, Bypass divider 5, 50uA charge pump, AUX enabled, source OUT 3, internal loop filter
    { //0x0BD0037F
      ( 0x0BC00000                  // 7: Factory default upper bits 27-21
      // Values for lower bandwidth filter to provide better dejitter
      // characteristics:
      | DEJ_LOOP_FILTER_C2_MAX
      | DEJ_LOOP_FILTER_R2_4_K_OHM
      | DEJ_LOOP_FILTER_C1_MAX
      | DEJ_LOOP_FILTER_C3_MAX
      | DEJ_LOOP_FILTER_R3_10_K_OHM
      )
    }
};


/** @brief AD9553 register base values for registers 0x0A-0x29 */
static const UINT8 AD9553RegisterBaseValues[] =
{
		/* PLL and PFD control 0x0A - 0x0D */
		
		0x56, /* Register 0x0A: PLL Charge Pump current (n x 3.5 uA) */
		0xB0, /* Register 0x0B: Charge pump and PFD control register */
		0x00, /* Register 0x0C: Charge Pump PFD clock dividers (used for test only via test mux */
		0x00, /* Register 0x0D: Antibacklash control [7:6} and PLL Lock detector power down [0] */

		/* Register 0x0E: VCO control */
		0xF4, /* Register 0x0E: VCO control, force VCO calibration which starts after I/O update  */
		0x80, /* Register 0x0F: VCO level control, controls VCO amplitude */
		0x80, /* Register 0x10: VCO band control,  controls VCO frequency band */
		0x00, /* Register 0x11: Unused */
		0x00, /* Register 0x12: Bits [19:12] of Feedback divider (N) */
		0x18, /* Register 0x13: Bits [11:4 ] of Feedback divider (N) */
		0x0C, /* Register 0x14: Bits [11:4 ] of Feedback divider (N) and misc. control bits */
		0x01, /* Register 0x15: Bits [ 9:2 ] of the 11 bit P1 divider */
		0x40, /* Register 0x16: Bits [ 1:0 ] of the 11 bit P1 divider & [9:4] of P2 divider */
		0x51, /* Register 0x17: Bits [ 3:0 ] of the 11 bit P2 divider and test port control */
		0x20, /* Register 0x18: Bits [ 2:0 ] of the 11 bit P0 divider */
		0x20, /* Register 0x19: Unused */
		0x00, /* Register 0x1A: Input receiver and Band gap control */
		
		/* XTAL control (registers 0x1B to 0x1E) */
		0x00, /* Register 0x1B: XTAL tuning capacitor control */
		0x00, /* Register 0x1C: Unused */
		0x00, /* Register 0x1D: Unused */
		0x00, /* Register 0x1E: Unused */
		
		/* REFA frequency control: 0x1F-0x21 */
		0x00, /* Register 0x1F: Bits [13:6] of the 14-bit REFA divider */
		0x12, /* Register 0x20: Bits [5:0] of the 14-bit REFA divider and SPI port divider control */
		0xA0, /* Register 0x21: REFA x2A and /5A select and SPI control */
		
		0x00, /* Register 0x22: Unused */
		
		/* REFB frequency control: 0x23-0x25 */		
		0x00, /* Register 0x23: */
		0x12, /* Register 0x24: */
		0xA0, /* Register 0x25: */
		
		0x00, /* Register 0x26: Unused */
		
		/* DCXO frequency and referecne switchover control */ 
		0x07, /* Register 0x27: */
		0xD2, /* Register 0x28: */
		0x00, /* Register 0x29: */
};

/** @brief AD9553 register base values for registers 0x32-0x39 */
static const UINT8 AD9553RegisterUpperValues[] =
{
		
        0xA1, /* Register 0x32: OUT1 driver control 0xA1: strong drive strength, active, LVDS, register control mode */
		0x00, /* Register 0x33: Unused */
        0xA1, /* Register 0x34: OUT2 driver control 0xA1: strong drive strength, active, LVDS, register control mode */
		0x00, /* Register 0x35: */
		0x80, /* Register 0x36: */
		0x0C, /* Register 0x37: */
		0xDC, /* Register 0x38: */
		0xFF, /* Register 0x39: */
};


void MillisecondWait(UINT32 ms)
{
    UINT32 ts;
    
    ms *= ClkRstGetFreq(XP_AXI) / 1000;
    ts = MxGetTicks();
    while ((MxGetTicks() - ts) < ms)
        {};    
}
// Bit reflect byte
UINT8 MsbLsbConvert8(UINT8 nVal)
{
    UINT8 nNew = 0x0;
    UINT8 i;

    for (i = 0; i <= 7; i++)
    {
        nNew = nNew << 1;
        nNew |= (nVal >>i )&0x01;
    }

    return nNew;
}

#ifdef DEBUG_DEJITTER
UINT32 DejitterDumpStart = 2;
UINT32 DejitterDumpEnd   = 3;
#endif

#ifdef DEBUG_DEJITTER
/** @brief Function to dump register values from the main dejitter PLL device */
static UINT32 DejitterDumpRegisters(char * InfoString, UINT32 gpio, UINT32 start, UINT32 length)
{
    UINT32 i=start;
    UINT32 j=(i+length)-1;
    UINT32 readData;
    
    if (InfoString)
    {
        uart_printf(InfoString);
    }
    for (; i<=j; i++)
    {
        readData = DejitterRead(i,gpio);
        uart_printf("Dejitter Register 0x%04X read:0x%8.8X\n",
                   i,
                   readData
                   );
        MillisecondWait(20); // Delay to make sure all data displayed
    }
    return SYSRC_SUCCESS;
}
#endif

/**
 * @brief function to dump all registers from the dejitter devices
 */
static UINT32 DejitterDumpAllRegisters(char * InfoString, UINT32 gpio)
{
#ifdef DEBUG_DEJITTER
    UINT32 i,j;
    UINT32 readData;
    
    if (IS_FEMTOCELL_BOARD())
    {
    	if (gpio == (1<<DEJITTER_CS_GPIO))
    	{
    		// AD9548 0x0-0x0E3F (with gaps)
                // 0xD00-0xD19 status register
    		i = 0xd00;
    		j = 0xd19;
    		
    	}
    	else
    	{
    		// AD9553 0, 0x04-0x34
            i = 0;
        	j = 0x34;  		
    	}

    }
    else
    {
    	// TI CDCE62005
        i = 0;
    	j = 7;
    }
    if (InfoString)
    {
        uart_printf(InfoString);
    }
    for (; i<=j; i++)
    {
        readData = DejitterRead(i,gpio);
        uart_printf("Dejitter Register 0x%04X read:0x%8.8X\n",
                   i,
                   readData
                   );
        MillisecondWait(20); // Delay to make sure all data displayed
    }
#endif
    return MX_OK;
}

/**
 * @brief Function to compare values of the dejitter PLL versus a table of values
 *
 * @returns 0 if OK, else if mismatch, returns number of mismatches
 */
UINT32 DejitterCompareAllRegisters(PUINT32 pDataToCompare, UINT32 gpio)
{
	UINT32 i;
	UINT32 rc=0;
	UINT32 readData;
	UINT32 compareData;
	for (i=0; i<8; i++)
	{
		readData = DejitterRead(i,gpio);
        if (i==7)
        {
        	// For register 7, read only bit 27 is sometimes 0, sometimes 1
        	// Force it high which is the documented value in the TI spec
            readData |= 0x08000000;
        }      
		compareData = *pDataToCompare++; 
		if (readData != compareData)
		{
			uart_printf("Dejitter Register %u read:0x%8.8X expected:0x%8.8X\n",
				   i,
				   readData,
				   compareData
				   );
			rc++;
		}		
	}
	return rc;
}

UINT32 DejitterWriteAllRegisters(PUINT32 pDataToWrite,UINT32 gpio)
{
	UINT32 i;
	for (i=0; i<8; i++)	{
		DejitterWrite(i,pDataToWrite[i],gpio);
	}
	return(DejitterCompareAllRegisters(pDataToWrite,gpio));
}

#ifdef DEBUG_DEJITTER
UINT32 SpiReadTest = 0;
#endif

void AD9548Write(UINT32 Reg, UINT32 Val)
{
	DejitterWrite(Reg,Val,(1<<DEJITTER_CS_GPIO));
}

UINT32 AD9548Read(UINT32 Reg)
{
	return(	DejitterRead(Reg,(1<<DEJITTER_CS_GPIO)));
}

void AD9548WriteBlock(UINT32 RegBase, PUINT8 pInitData, UINT32 TableByteSize)
{	
	UINT32 Val;
	
	while(TableByteSize--)
	{
		Val = (UINT32)(*pInitData++);
		AD9548Write(RegBase++,Val);
	}
}

void DejitterSelectSource(UINT32 ClockSourceId)
{
    if (!IS_FEMTOCELL_BOARD())
    {
        // Don't do anything except for femtocell board 
        return;
    }
    AD9548Write(0xa00,0); // Write 0 to 0xA00 to put 9548 into normal mode
    
    if (ClockSourceId < 8)
    {
        // Select source A, AA, B, BB, etc.
        // TEMP DEBUG CODE, SETUP FOR TXCO TESTING
        AD9548Write(0xA01,
                       0
                    | (0<<6) // 0:   User holdover, nomral operation
                    | (0<<5) // 0: Freerun mode, not forced into free run (normal automatic mode)
                  //| (0<<3) // 00:  Automatic mode
                  //| (1<<3) // 01:  Fallback  mode
                  //| (2<<3) // 10:  Holdover mode
                    | (3<<3) // 11:  Manual mode (reference selected in bits 2:0
                    | (ClockSourceId<<0) // Select clock source 0-7
                   ); // Force the device into free-run mode
        
    }
    else
    {
        // Force AD9548 into freerun mode
        // TEMP DEBUG CODE, SETUP FOR TXCO TESTING
        AD9548Write(0xA01,
                    0
                    | (0<<6) // 0:   User holdover, nomral operation
                    | (1<<5) // 1:   Force device into free run mode
                  //| (0<<3) // 00:  Automatic mode
                  //| (1<<3) // 01:  Fallback  mode
                  //| (2<<3) // 10:  Holdover mode
                    | (3<<3) // 11:  Manual mode (reference selected in bits 2:0
                    | (0<<0) // Select clock source 0-7 (disabled, free run)
                   ); // Force the device into free-run mode
    }
    //
    // Generate the output clock
    // Set and clear the sync distribution bit to generate a clock
    // distribution sync pulse, which causes the synthesized output signal
    // to appear at the clock distribution outputs
    // 
    // Calibrate the system clock, write bit 1 of 0xa02 register, then clear bit
    // each time with an I/O update
    AD9548Write(0xa02,(1<<1));

#if 1
    
    if (ClockSourceId < 8)
    {
        //
        // Start profile selection State machine based on desired inputs (1 for start, 0 for ignore)
        //
        AD9548Write(0xa0d, (1 << ClockSourceId) // Detect selected input reference
                   );
#if 0        
        //
        // Select any signals that override the reference monitor fault signal (1 == override, 0 == not overrided)
        //
        AD9548Write(0xa0f, (1 << ClockSourceId)
                   );
#endif
#if 0
    
        //
        // Select any signals that bypass the reference monitor for the inputs (1 == bypass, 0 == monitor enabled)
        //
        AD9548Write(0xa10, (1 << ClockSourceId)
                   );      
#endif  
    }
    else
    {
        // No source selected, shut down state machine based on all inputs disabled
        AD9548Write(0xa0d, 0);
    }
#endif
    
      
    AD9548Write(5,1);
    AD9548Write(0xa02,0);
    AD9548Write(5,1);
}
void AD9553Write(UINT32 Reg, UINT32 Val)
{
	DejitterWrite(Reg,Val,(1<<(DEJITTER_CS_GPIO+1)));
}

UINT32 AD9553Read(UINT32 Reg)
{
	return(	DejitterRead(Reg,(1<<(DEJITTER_CS_GPIO+1))));
}

void AD9553WriteBlock(UINT32 RegBase, PUINT8 pInitData, UINT32 TableByteSize)
{	
	UINT32 Val;
	
	while(TableByteSize--)
	{
		Val = (UINT32)(*pInitData++);
		AD9553Write(RegBase++,Val);
	}
}
#ifdef DEBUG_DEJITTER
UINT32 PauseDejitterInit=0;
UINT32 DejitterResetTest=0;
#endif

/** @brief Function to initialize PLLs on Mindspeed EVM board to a functioning state.
 */
MXRC DejitterInit  (UINT32 InitOption, UINT32 ClockSource)
{
    UINT32    writeData;
    UINT32    readData;
    UINT32    i;
    MXRC rc = MX_OK;
//    UINT32    BurnDejitterEEPROM     = 0;  // AKB: Set to 1 to burn values to EEPROM
    PUINT32   DejitterDefaultConfig;

    SPICONFIG * pSpiConfig = NULL;

    if (!SPIIsInit())
    {
        rc = SPIInit (SPI_DEF_DEV_NUM);

        if (FAILED(rc))
        {
            uart_printf ("SPI driver initialization error, rc=%x\r\n", rc);
            return rc;
        }
    }
    
    // Print dejitter start message (femtocell takes longer so adding basic
    // progress messages
    uart_printf("Dejitter/Clocking PLLs Init Option %u, Source: %u\n",InitOption,ClockSource+1);
    if (InitOption <= DEJITTER_INIT_IDLE)
    {
    	DejitterDefaultConfig = (PUINT32) DejitterIdleConfig;    	
    }
    else if (InitOption == DEJITTER_INIT_RADIO)
    {
    	DejitterDefaultConfig = (PUINT32) DejitterRadioConfig;
    }
    else
    {
    	DejitterDefaultConfig = (PUINT32) DejitterCpriConfig;
    }
    //
    // Initialize the Cypress PLL to correct input clocks, output clocks
    // divisors, etc. prior to setting up the TI or Analog devices dejitter device
    //
    // NOTE: The Femtocell board, full size EVM and low cost EVM all
    // have a Cypress PLL CY22393 as part of the dejitter circuit
    // CypressPLLInit determines board type and based on that outputs
    // the correct data to program the part via I2C to the external Cypress PLL.
    //    
    //if (InitOption == DEJITTER_INIT_STARTUP)
    //{
    	uart_printf("CY22393: ");
        CypressPLLInit(InitOption);
        uart_printf("OK, ");
    //}

    if (InitOption <= DEJITTER_INIT_IDLE)
    {
         return MX_OK; // don't initialize AD9548 or AD9553 unless Radio or CPRI selected        
    }        

    //
    // Initialize SPI operation (both TI and Analog Devices communicate
    // using SPI interface)
    //
    // Setup SPI options

    pSpiConfig = SPICreateDevCtx();

    if (pSpiConfig == NULL)
    {
        uart_printf ("DeJitter: SPI-driver device allocation error\r\n");
        return RC_DEITTER_SPI_CTX_ERROR;
    }

    pSpiConfig->frameSize       = SPI_FRAME_SIZE_8BITS;
    pSpiConfig->frameFormat     = SPI_MOTOROLA_FORMAT;
    pSpiConfig->clkMode         = SPI_CLOCK_MODE3;
    pSpiConfig->transferMode    = SPI_RX_TX_ENABLE;
    pSpiConfig->CS              = 0;

    if (IS_FEMTOCELL_BOARD())
    {
    	// AD9548, set to 1 megabit speed
        //SpiConfig.frqDivider = SPI_DIVIDER_SPEED_1M;
    	pSpiConfig->frqDivider = SPI_DIVIDER_SPEED_KHZ(225); // Set to same speed as AD9548 Eval board
    }
    else
    {
        pSpiConfig->frqDivider   = SPI_DIVIDER_SPEED_KHZ(500);//300;//SPI_DIVIDER_SPEED_1M;    
    }

    // Initialize SPI driver
    rc = SPISelectDevice(pSpiConfig);

    if (FAILED(rc))
    {
        SPIRemoveDevCtx(pSpiConfig);
        pSpiConfig = NULL;
        printf ("SPI driver select device error, rc=%x\r\n", rc);

        return rc;
    }

    if (IS_FEMTOCELL_BOARD())
    {
        // Setup GPIO for SPI (NOTE: same GPIO is used for dejitter function
        // on EVM and Femtocell reference board for the main dejitter chip.
    	// The femtocell board has a second PLL as well which is the GPIO
    	// + 1
        REG32(GPIO_OE_REG)         |= (1<<DEJITTER_AD9548_CS_GPIO) | (1<<DEJITTER_AD9553_CS_GPIO) | (1<<BRCM_SWITCH_CS_GPIO) | (1<<RADIO_AD9361_CS_GPIO);        
        REG32(GPIO_OUTPUT_REG)     |= (1<<DEJITTER_AD9548_CS_GPIO) | (1<<DEJITTER_AD9553_CS_GPIO) | (1<<BRCM_SWITCH_CS_GPIO) | (1<<RADIO_AD9361_CS_GPIO); 
        REG32(GPIO_PIN_SELECT_REG) |= (1<<DEJITTER_AD9548_CS_GPIO) | (1<<DEJITTER_AD9553_CS_GPIO) | (1<<BRCM_SWITCH_CS_GPIO) | (1<<RADIO_AD9361_CS_GPIO);
    }
    else
    {
        // Enable Internal SPI controller Chip select for dejitter device
    	// NOTE: Actual external chip select changed below to be direct driven by GPIO commands 
        SPIEnableCS(SPIGetCtrlRegs(), SPI_DEJITTER_CS);
        // Setup GPIO for SPI (NOTE: same GPIO is used for dejitter function
        // on EVM and Femtocell reference board
        REG32(GPIO_OE_REG)         |= (1<<DEJITTER_CS_GPIO) | (1<<DEJITTER_DIV_SYNC_GPIO);
        REG32(GPIO_OUTPUT_REG)     |= (1<<DEJITTER_CS_GPIO) | (1<<DEJITTER_DIV_SYNC_GPIO);
        REG32(GPIO_PIN_SELECT_REG) |= (1<<DEJITTER_CS_GPIO) | (1<<DEJITTER_DIV_SYNC_GPIO);

    }
   
    if (IS_FEMTOCELL_BOARD())
    {
        uart_printf("AD9548/9553: ");
#ifdef DEBUG_DEJITTER 
      do
      {
#endif
    	//
    	// For femtocell board, we only initialize the clock once at startup.
    	// This is as for this board, clocking is the same setup for 
    	// Radio and CPRI mode as the board's clocking is setup to
    	// always provide the proper clock for both operations
    	//
    	// So if not startup init, just return
    	//
#if 0    	
        if (InitOption != DEJITTER_INIT_STARTUP)
        {
        	uart_printf("OK\n");
            return;
        }
#endif        
    	// Write to register 0 to setup default values for operation + reset to put 
    	// AD9548 and AD9553 chips into a known state
#if 1
        uart_printf("Reset, ");
#ifdef DEBUG_DEJITTER         

#endif
    	DejitterWrite(0,
    			      0
    			      | (1<<7)  // 1 4wire mode, 0 (default) 3wire mode
    			      | (0<<6)  // 1 Least significant bit & Byte first, 0 (default) MSB and msb
    			      | (1<<5)  // 1 Reset, 0 (default) normal opearation
    			      | (1<<4)  // Read only, always one
    			      // Inverse data (to allow for register 0 in lsb or msb mode
    			      //| (1<<3) | (1<<2) | (0<<1) | (1<<0)
    			      ,
    			      (1<<(DEJITTER_CS_GPIO))
    			     );
#ifdef AD9553    	
    	DejitterWrite(0,
    			      0
    			      | (0<<7)  // Bit 7: Reserved, always 0
    			      | (0<<6)  // Bit 6: 1 Least significant bit & Byte first, 0 (default) MSB and msb
    			      | (1<<5)  // Bit 5: 1 Reset, 0 (default) normal opearation
    			      | (1<<4)  // Bit 4: Read only, always 1
    			      // Inverse data (to allow for register 0 in lsb or msb mode
    			      //| (1<<3) | (1<<2) | (0<<1) | (0<<0)
    			      ,
    			      (1<<(DEJITTER_CS_GPIO+1))
    			     );
#endif    	

    	SysDelay(100);

#if 0
        //
        // TEMP FOR TCXO DEBUG, ALWAYS SETUP CLOCK AT STARTUP
        // SO IT CAN BE MEASURED
        //
        if (InitOption <= DEJITTER_INIT_IDLE)
        {
            // If IDLE or STARTUP, chips are reset and should be shutdown
            // make sure by killing output
            DejitterWrite(0x401,0x00,(1<<(DEJITTER_CS_GPIO ))); // Set AD9548 OUT0 - OUT3 to disabled
            DejitterWrite(0x32,0xE1,(1<<(DEJITTER_CS_GPIO+1))); // Set AD9553 OUT1 to powered down
            DejitterWrite(0x34,0xE1,(1<<(DEJITTER_CS_GPIO+1))); // Set AD9553 OUT2 to powered down
            uart_printf("Disabled/n");
            return;
        }
#endif

#endif // #if 1 on chip reset 

#ifdef DEBUG_DEJITTER 
        uart_printf("Release from reset AD9548\n");
#endif
    	// Write to register 0 to setup default values for operation
    	DejitterWrite(0,
    			      0
    			      | (1<<7)  // 1 4wire mode, 0 (default) 3wire mode
    			      | (0<<6)  // 1 Least significant bit & Byte first, 0 (default) MSB and msb
    			      | (0<<5)  // 1 Reset, 0 (default) normal opearation
    			      | (1<<4)  // Read only, always 1
    			      // Inverse data (to allow for register 0 in lsb or msb mode
    			      //| (1<<3) | (0<<2) | (0<<1) | (1<<0)
    			      ,
                      (1<<(DEJITTER_CS_GPIO))
    			     );
#ifdef AD9553    	
#if 0    	
        //
        // AKB TEMP PATCH FOR TESTING AD9553
        // AD9553 AND AD9548 ARE BOTH HOOKED UP TO GPIO 12 FOR RESET
        // BUT UNFORTUNATELY, AD9548 USES RESET AND AD9553 USES OPPOSITE POLARITY
        // RESET_N.
        // TEMP FOR TEST, SETUP GPIO 12 AS OUTPUT AND SET TO HIGH POLARITY
        // TO TAKE THE AD9553 OUT OF RESET (NOTE THIS WILL PUT THE AD9548 INTO RESET
        //
        uart_printf("Releasing AD9553 from physical reset\n");
        REG32(GPIO_OE_REG)         |= GPIO_12;
        REG32(GPIO_OUTPUT_REG)     &= ~(GPIO_12);
        REG32(GPIO_PIN_SELECT_REG) |= GPIO_12;
        SysDelay(1000);
#endif        
    	// Write to register 0 to setup default values for operation
    	DejitterWrite(0,
    			      0
    			      | (0<<7)  // Bit 7: Reserved, always 0
    			      | (0<<6)  // Bit 6: 1 Least significant bit & Byte first, 0 (default) MSB and msb
    			      | (0<<5)  // Bit 5: 1 Reset, 0 (default) normal opearation
    			      | (1<<4)  // Bit 4: Read only, always 1
    			      // Inverse data (to allow for register 0 in lsb or msb mode
    			      //| (1<<3) | (0<<2) | (0<<1) | (0<<0)
    			      ,
                      (1<<(DEJITTER_CS_GPIO+1))
    			     );
#endif    	
        SysDelay(100);
#ifdef DEBUG_DEJITTER        
        
        do
        {
    	  DejitterDumpAllRegisters("AD9548 Status Registers after reset:\n",(1<<(DEJITTER_CS_GPIO)));    // AKB TEMP DEBUG
#ifdef AD9553    	  
    	  DejitterDumpAllRegisters("AD9553 Registers after reset:\n",(1<<(DEJITTER_CS_GPIO+1)));    // AKB TEMP DEBUG
#endif    	  
        }
        while (SpiReadTest);
#endif        
        //
        // Program AD9553
        //
        // Program base registers from 0x0A to 0x29
        //
        AD9553WriteBlock(0x0A,(PUINT8)&AD9553RegisterBaseValues, sizeof(AD9553RegisterBaseValues));
        //
        // Program upper registers from 0x32 to 0x39
        //
        AD9553WriteBlock(0x32,(PUINT8)&AD9553RegisterUpperValues, sizeof(AD9553RegisterUpperValues));
        //
        // Issue I/O update
        //
        AD9553Write(5,1);
        
#ifdef DEBUG_DEJITTER        
        DejitterDumpRegisters("AD9553 register read back:\n",
        		              (1<<(DEJITTER_CS_GPIO+1)),
        		              0x0,
        		              0x39
        		             );
        DejitterDumpRegisters("AD9553 status read back:\n",
        		              (1<<(DEJITTER_CS_GPIO+1)),
        		              0xFE,
        		              0x2
        		             );
#endif        
        
        
        uart_printf("Programming, ");
        // Follow initialization steps as outlined in AD9548 datasheet
        
        // Program 0x100 register bank
        AD9548WriteBlock(0x100,(PUINT8)&AD9548Register100BankValues, sizeof(AD9548Register100BankValues));
        
        // Initialize the system clock by writing to register 5, Bit 0 (self clearing)
        // Send an I/O update
        AD9548Write(5,1);
        SysDelay(10);

#ifdef DEBUG_DEJITTER        
        DejitterDumpRegisters("0x100 bank read back:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0x100,
        		              sizeof(AD9548Register100BankValues)
        		             );
        DejitterDumpRegisters("0xD00 Status read:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0xD00,
        		              0x19
        		             );
        while(PauseDejitterInit==1);

#endif        
#if 0
        // TEMP DEBUG CODE TO RESET CHIP, BUT PRESERVE REGISTER SETTINGS
        AD9548Write(0xa00,0x80);
        AD9548Write(5,1);
        SysDelay(500);
        AD9548Write(0xa00,0x00);
        AD9548Write(5,1);
        SysDelay(1000);
#endif        
        


#if 1       
        // Calibrate the system clock, write bit 0 of 0xa02 register, then clear bit
        // each time with an I/O update
        AD9548Write(0xa02,1);
        AD9548Write(5,1);
        SysDelay(500); // Set to 1/2 second, same as that used in the AD9548 evaluation software
        AD9548Write(0xa02,0);
        AD9548Write(5,1);
        SysDelay(10);
#endif        

#ifdef DEBUG_DEJITTER        

        DejitterDumpRegisters("0xD00 bank read back after calibration:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0xD00,
        		              0x20
        		             );
        
        while (PauseDejitterInit==2);
#endif        

        //
        // AD9548 Watchdog, interrupts, etc. are not used, so register 0x200 bank is skipped
        
        //
        // Program the Digital Phase-Locked Loop (DPLL)
        // Output register space for 0x300 bank of registers
        //
        AD9548WriteBlock(0x300,(PUINT8)&AD9548Register300BankValues, sizeof(AD9548Register300BankValues));
        
        //
        // Register bank 0x400
        // Program the clock distribution outputs
        // based on functional mode for Radio, CPRI or startup/idle
        //
        if (InitOption != DEJITTER_INIT_RADIO)
        {
            // CPRI (or other future clock option) clock selected, power up and enable all 4 output clocks from the AD9548
            AD9548Write(0x400, 0x0);
            AD9548Write(0x401, 0xF);
        }
        else
        {
            //
            // Radio clock, only output 40 MHz clock to radio (OUT0) and 10 MHz clock to SMA conntector
            // This currently disables clock to devices such as the T4K TSU function, but this
            // creates less noise on the current MSPD T4K EVM that can be picked up by the radio
            // and cause some interference.
            //
            AD9548Write(0x400, 0x6);
            AD9548Write(0x401, 0x9);
        }
        //
        // Output the rest of the registers for the 0x400 bank of AD9548 registers
        //
        AD9548WriteBlock(0x402,
                         ((PUINT8)&AD9548Register400BankValues)+2, 
                         sizeof(AD9548Register400BankValues)-2
                        );
        
        //
        // To match EEPROM startup sequence isse an I/O update after registers
        // 0x300 and 0x400 register block programming is complete
        //
        AD9548Write(5,1);
        SysDelay(10);

#ifdef DEBUG_DEJITTER        
        SysDelay(5000);
        DejitterDumpRegisters("0xD00 bank read back after 0x400 bank written:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0xD00,
        		              0x20
        		             );
        
        while (PauseDejitterInit==3);
#endif        
        
        //
        // Register bank 0x500
        // Program the clock distribution outputs
        //
        AD9548WriteBlock(0x500,(PUINT8)&AD9548Register500BankValues, sizeof(AD9548Register500BankValues));
        
        //
        // Register banks 0x600, 0x680, 0x700 and 0x780
        // Program the reference profiles 0-7 (2 profiles per register bank)
        //
        AD9548WriteBlock(0x600,(PUINT8)&AD9548Register600BankValues, sizeof(AD9548Register600BankValues));

        // Program profiles 2-7 if present
//#if defined(AD9548Register680BankValues)        
        AD9548WriteBlock(0x680,(PUINT8)&AD9548Register680BankValues, sizeof(AD9548Register680BankValues));
//#endif
//#if defined(AD9548Register700BankValues)           
        AD9548WriteBlock(0x700,(PUINT8)&AD9548Register700BankValues, sizeof(AD9548Register700BankValues));
//#endif        
//#if defined(AD9548Register780BankValues)           
        AD9548WriteBlock(0x780,(PUINT8)&AD9548Register780BankValues, sizeof(AD9548Register780BankValues));
//#endif        
        
        //
        // Issue an I/O update to invoke all of the register settings
        // programmed up to this point
        //
        AD9548Write(5,1);
        SysDelay(10);
        
#ifdef DEBUG_DEJITTER        
        SysDelay(5000);
        DejitterDumpRegisters("0xD00 bank read back after 0x700 bank written:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0xD00,
        		              0x20
        		             );
        
        while (PauseDejitterInit==4);
#endif  
        
        // Generate the reference aquisition (PLACEHOLDER FOR FUTURE CODE,
        // FOR NOW, JUST GO WITH A FIXED REFERENCE OR FREE RUN
        

        // Register bank 0xa00, just need selected registers
        SysDelay(1000);
       
        // Start off by selecting Free run clock (this may be changed
        // later).
        DejitterSelectSource(ClockSource);
        

#ifdef DEBUG_DEJITTER        
        SysDelay(1000);
 	    DejitterDumpAllRegisters("AD9548 status Registers after 0xA00 registers written:\n",(1<<(DEJITTER_CS_GPIO)));    // AKB TEMP DEBUG
#endif

        
 
#ifdef DEBUG_DEJITTER        
        SysDelay(1000);
        DejitterDumpRegisters("0x300 bank read back:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0x300,
        		              sizeof(AD9548Register300BankValues)
        		             );
        DejitterDumpRegisters("0x400 bank read back:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0x400,
        		              sizeof(AD9548Register400BankValues)
        		             );        
        DejitterDumpRegisters("0x500 bank read back:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0x500,
        		              sizeof(AD9548Register500BankValues)
        		             );     
        DejitterDumpRegisters("0x600 bank read back:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0x600,
        		              sizeof(AD9548Register600BankValues)
        		             );    
        DejitterDumpRegisters("0x700 bank read back:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0x700,
        		              sizeof(AD9548Register700BankValues)
        		             );   
        DejitterDumpRegisters("0xA00 bank read back:\n",
        		              (1<<DEJITTER_CS_GPIO),
        		              0xA00,
        		              0x11
        		             );   
        SysDelay(1000);
 	    DejitterDumpAllRegisters("AD9548 Registers after init & delay:\n",(1<<(DEJITTER_CS_GPIO)));    // AKB TEMP DEBUG
#endif
 	    
        // Make sure after all this programming AD9548 SYSCLK PLL is OK
 	    readData = AD9548Read(0xD01);
 	    uart_printf("SYSCLK: ");
 	    if (readData == 0x11)
 	    {
 	    	// SYSCLK is OK, wait one 
 	    	uart_printf("DPLL: ");
 	    	// Give time to PLL to allow for lock to input clocks
 	    	i = 500;
 	    	do
 	    	{
 	    		// Read DPLL status, should be 0x32 (phase locked, frequency locked and running)
 	    		readData = AD9548Read(0xD0A);
 	    		if (readData == 0x32)
 	    		{
 	    			uart_printf("OK\n");
 	    			break;
 	    		}
 	    	} while (i--);
 	    	if (i==0)
 	    	{
 	    		uart_printf("FAILED VALUE: 0x%02X\n",readData);
 	    	}
 	    }
 	    else
 	    {
 	    	uart_printf("FAILED VALUE: 0x%02X\n",readData);
 	    }
#ifdef DEBUG_DEJITTER 	    
 	    SysDelay(5000);
      } while (DejitterResetTest); 	    
#endif
        
    	return MX_OK;
    }
    else
    {
    	// Not femtocell board, T4K EVMs use TI CDCE62005
    //
    // AKB TEMP, TRY DOING A DUMMY READ TO SEE IF REGISTER 0 READS
    // OK
    //
        (void)DejitterRead(0,(1<<DEJITTER_CS_GPIO));

    //
    // Clear out the entire register 8 to put the chip into sleep mode.
    // This also causes the chip to clear out old calbration word
    // info
    //
        DejitterDumpAllRegisters("Registers Before setting Sleep Mode:\n",(1<<DEJITTER_CS_GPIO));    // AKB TEMP DEBUG
        DejitterWrite(8,0,(1<<DEJITTER_CS_GPIO));
    //
    // Check current RAM register data against Defaults
    //
    DejitterDumpAllRegisters("Registers Prior to Write:\n",(1<<DEJITTER_CS_GPIO));  // AKB TEMP DEBUG
    if (DejitterWriteAllRegisters((PUINT32)DejitterDefaultConfig,(1<<DEJITTER_CS_GPIO))!=0)
	{
        uart_printf("FATAL ERROR: Dejitter RAM register compare failure\n");
        return RC_DEITTER_RAM_REG_ERROR;
	}
        DejitterDumpAllRegisters("Registers After Write:\n",(1<<DEJITTER_CS_GPIO)); // AKB TEMP DEBUG
#if 0	
        if (DejitterCompareAllRegisters((PUINT32)DejitterDefaultConfig,(1<<DEJITTER_CS_GPIO))!=0)
    {
        uart_printf("Setting mode, writing all TI CDCE62005 Registers:\n");
    	// There was at least one mismatch
        	if (DejitterWriteAllRegisters((PUINT32)DejitterDefaultConfig,(1<<DEJITTER_CS_GPIO))!=0)
    	{
            uart_printf("FATAL ERROR: Dejitter RAM register compare failure\n");
            return;
    	}
    	if (InitOption == DEJITTER_INIT_STARTUP)
    	{
    		// Setup to burn EEPROM if mismatch on startup 
        BurnDejitterEEPROM     = 1;
    	}
    }
    
    if (BurnDejitterEEPROM)
    {
    	uart_printf("Burning Dejitter Device\n");
        DejitterUnlock();
        MillisecondWait(200);  // Spec says wait for 50 ms, using 200 to be safe
        uart_printf("RAM register Values burned to EEPROM\n");
        //uart_printf("Please Power Cycle and reload system to validate proper values programmed\n");
    }
#endif
    //
    // Exit sleep mode.  Also very important to also make sure
    // that the chip is not in Sync state (otherwise the chip
    // does go into normal mode, but it doesn't
    // generate output clock unless the chip is told 
    // to exit syncrhonization state
    // 
    // By exiting sleep mode with automatic calibraton enabled,
    // this causes the chip to relock on the clock coming out of the
    // NTG which should now be at the proper rate.
    //
    writeData = DEJ_SLEEP_MODE_OFF | DEJ_EXIT_SYNC_STATE;
        DejitterWrite(8,writeData,(1<<DEJITTER_CS_GPIO));
    #ifdef DEBUG_DEJITTER    
        DejitterDumpAllRegisters("Registers After Exit Sleep Mode:\n",(1<<DEJITTER_CS_GPIO));    // AKB TEMP DEBUG
    MillisecondWait(1000);
        DejitterDumpAllRegisters("Registers After One second wait:\n",(1<<DEJITTER_CS_GPIO));    // AKB TEMP DEBUG
#endif    
//    F   I   P   O
//    32  1   2   24
//    500 16  2   24  40.000000    
//    DejitterConfig[3] &= ~(0x7F<<13);
    uart_printf("OK\n");
    }

    SPISelectDevice (NULL);
    SPIRemoveDevCtx(pSpiConfig);
    pSpiConfig = NULL;

    return MX_OK;
}

void DejitterSendCommand(UINT32 cmd)
{
    UINT8 command[4] = {0};

    command[0] = MsbLsbConvert8((UINT8) (cmd     &0xFF)); //bit 0 : bit7
    command[1] = MsbLsbConvert8((UINT8)((cmd>>8) &0xFF)); //bit8  : bit15
    command[2] = MsbLsbConvert8((UINT8)((cmd>>16)&0xFF)); //bit16 : bit23
    command[3] = MsbLsbConvert8((UINT8)((cmd>>24)&0xFF)); //bit24 : bit31

    SPISetClockMode(SPI_CLOCK_MODE3);

    CS_LOW(DEJITTER_CS_GPIO);
    SPISendByte(command[0]);
    SPISendByte(command[1]);
    SPISendByte(command[2]);
    SPISendByte(command[3]);
    CS_HIGH(DEJITTER_CS_GPIO);
}

/** 
 * @brief Function to read a single value from register address passed
 *
 * @details
 *
 * For AD9548, this reads a single byte but returns it as
 * 32 bits
 *
 * For TI, reads 32 bits and then shifts the data by 4 bits to 
 * Get 28 bits of actual data
 */

UINT32 DejitterRead(UINT32 addr, UINT32 gpio)
{
    UINT32 ts;
    UINT8 rx_data[4] =
    { 0xff, 0xff, 0xff, 0xff };
    UINT32 data;
    UINT32 SpiDejitterCs;

#ifdef AD9548_LSB_MODE        
    //
    // LSB mode, Address is sent first, but byte reversed
    //
    rx_data[0] = MsbLsbConvert8((UINT8) (addr     &0xFF));            //address bits A0:A7
    rx_data[1] = MsbLsbConvert8((UINT8) ((  ((addr>>8) & 0x1f)        //address bits A8:A12
     		                              |  AD9548_READ_CMD          //read operation
       		                              |  AD9548_XFER_ONE_BYTE_CMD //one byte read
       		                             )
       		                             & 0xFF
       		                            )
       		                   ); 
#else
    //
    // MSB mode, Most significant Address and command is sent first,
    // then remaining address bits
    //
    rx_data[0] = (UINT8) (  ((addr>>8) & 0x1f)        //address bits A8:A12
      		                |  AD9548_READ_CMD          //read operation
       		                |  AD9548_XFER_ONE_BYTE_CMD //one byte read
       		             ) & 0xFF
       		             ;     
    rx_data[1] = (UINT8) (addr &0xFF);            //address bits A0:A7
#endif
        
    if (IS_FEMTOCELL_BOARD())
    {
		SpiDejitterCs = SPI_DEJITTER_CS;
    	if (gpio == (1<<(DEJITTER_CS_GPIO+1)))
    	{
    		SpiDejitterCs++;
    	}
        // Code copied/modified from AD9361 radio driver which
    	// is another Analog Devices chipset that uses SPI
    	// in same manner as AD9548
        
        SPIEnableCS(SPIGetCtrlRegs(), SpiDejitterCs);
        
        REG32(GPIO_OUTPUT_REG) &= ~gpio;
        REG32(SPI_DR_REG) = rx_data[0]; // Upper address and read single byte command
        REG32(SPI_DR_REG) = rx_data[1]; // Lower address
        REG32(SPI_DR_REG) = 0;//0x55;//0;          // Dummy
        
        while (REG32(SPI_RXFLR_REG) < 3);
        
        rx_data[0] = (UINT8)REG32(SPI_DR_REG);
        rx_data[1] = (UINT8)REG32(SPI_DR_REG);
        rx_data[2] = (UINT8)REG32(SPI_DR_REG);
    
        REG32(GPIO_OUTPUT_REG) |= gpio;        
        SPIDisableCS(SPIGetCtrlRegs(), SpiDejitterCs);
        //uart_printf("SPI Read gpio 0x%08X: 0x%02x, 0x%02x, 0x%02x\n",gpio,rx_data[0],rx_data[1],rx_data[2]);
        data = rx_data[2] & 0xFF;
        
    }
    else
    {
    DejitterSendCommand((0x0E | (addr<<4))); // read command

    ts = MxGetTicks();
    while ((MxGetTicks() - ts) < 150000)
        {};

    SPISetClockMode(SPI_CLOCK_MODE1);

    CS_LOW(DEJITTER_CS_GPIO);
    SPISendReadByte(0xFF, &rx_data[0]);
    SPISendReadByte(0xFF, &rx_data[1]);
    SPISendReadByte(0xFF, &rx_data[2]);
    SPISendReadByte(0xFF, &rx_data[3]);
    CS_HIGH(DEJITTER_CS_GPIO);

    data =  (UINT32)MsbLsbConvert8((UINT8)(rx_data[0]))
        | (((UINT32)MsbLsbConvert8((UINT8)(rx_data[1]))) << 8)
        | (((UINT32)MsbLsbConvert8((UINT8)(rx_data[2]))) << 16)
            | (((UINT32)MsbLsbConvert8((UINT8)(rx_data[3]))) << 24)
            ;

    //May need to ignore 4 lowest bits
    data = data>>4;
    }

    return data;
}

void DejitterWrite(UINT32 addr, UINT32 data, UINT32 gpio)
{
	UINT8 byte1;
	UINT8 byte2;
	UINT32 SpiDejitterCs;
	
	
    if (IS_FEMTOCELL_BOARD())
    {
		SpiDejitterCs = SPI_DEJITTER_CS;
    	if (gpio == (1<<(DEJITTER_CS_GPIO+1)))
{
    		SpiDejitterCs++;
    	}
        // Code copied/modified from AD9361 radio driver which
    	// is another Analog Devices chipset that uses SPI
    	// in same manner as AD9548
        byte1 = (UINT8) (addr >> 8);
        byte2 = (UINT8) addr;
        
        SPIEnableCS(SPIGetCtrlRegs(), SPI_DEJITTER_CS);
        
        REG32(GPIO_OUTPUT_REG) &= ~gpio;
        REG32(SPI_DR_REG) = byte1;
        REG32(SPI_DR_REG) = byte2;
        REG32(SPI_DR_REG) = (UINT8)data;
        
        while (REG32(SPI_RXFLR_REG) < 3);
        
        // Need 3 dummy read operations for the above 3 write operations
        byte1 = REG32(SPI_DR_REG);
        byte2 = REG32(SPI_DR_REG);
        data  = REG32(SPI_DR_REG);
        
        REG32(GPIO_OUTPUT_REG) |= gpio;        
        SPIDisableCS(SPIGetCtrlRegs(), SPI_DEJITTER_CS);
        
        //uart_printf("Write gpio 0x%08X: Read back : 0x%02X, 0x%02X, 0x%02X\n",gpio,byte1,byte2,data);
        SysDelay(3);  //AD9548 eval board firmware has a delay between transactions
        
    }
	else
    DejitterSendCommand(((data << 4) | addr));
}

// unlock Function to copy from RAM to EEPROM
// See Table 5 in TI CDCE62005 spec
void DejitterUnlock()
{
    DejitterSendCommand(0x0000001F);
}

// eof dejitter.c
