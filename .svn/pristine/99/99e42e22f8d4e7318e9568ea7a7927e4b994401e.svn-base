/**
 * @file    get_opr_cfg_func.c
 * @section Copyright Powerwave Technologies, Inc., 2010
 * @section This is auto generated file from Excel
 * @section This file contains GET functions for all tables
 *
 * Author: Madhusudana Rao Kata
 * Date: 11-10-2010
 * Description: Draft version 
 * Generated on : 11-02-2013 14:40:18
 */

 
#include "get_oam_func.h"

/*******************************************************************/
/***************    OPERATOR CONFIG TABLE GET FUNCTIONS     ********/
/*******************************************************************/

/* GetData OprConfig */
EnbRegistrationConfig*    getDataEnbRegistrationConfigTable( IN RowId rowId )
{
  return   &(g_EnbRegistrationConfig[rowId]);
}
 
EnodebConfig*             getDataEnodebConfigTable( IN RowId rowId )
{
  return   &(g_EnodebConfig[rowId]);
}
 
MmeConfig*                getDataMmeConfigTable( IN RowId rowId )
{
  return   &(g_MmeConfig[rowId]);
}
 
CellConfig*               getDataCellConfigTable( IN RowId rowId )
{
  return   &(g_CellConfig[rowId]);
}
 
SchedulerConfig*          getDataSchedulerConfigTable( IN RowId rowId )
{
  return   &(g_SchedulerConfig[rowId]);
}
 
PhyConfig*                getDataPhyConfigTable( IN RowId rowId )
{
  return   &(g_PhyConfig[rowId]);
}
 
SysInfo1Config*           getDataSysInfo1ConfigTable( IN RowId rowId )
{
  return   &(g_SysInfo1Config[rowId]);
}
 
SysInfo2Config*           getDataSysInfo2ConfigTable( IN RowId rowId )
{
  return   &(g_SysInfo2Config[rowId]);
}
 
LogConfig*                getDataLogConfigTable( IN RowId rowId )
{
  return   &(g_LogConfig[rowId]);
}
 
RadioHeadConfig*          getDataRadioHeadConfigTable( IN RowId rowId )
{
  return   &(g_RadioHeadConfig[rowId]);
}
 
QosConfig*                getDataQosConfigTable( IN RowId rowId )
{
  return   &(g_QosConfig[rowId]);
}
 
PmCounterLogConfig*       getDataPmCounterLogConfigTable( IN RowId rowId )
{
  return   &(g_PmCounterLogConfig[rowId]);
}
 
EutraHoProfileConfig*     getDataEutraHoProfileConfigTable( IN RowId rowId )
{
  return   &(g_EutraHoProfileConfig[rowId]);
}
 
EutraNeighCellConfig*     getDataEutraNeighCellConfigTable( IN RowId rowId )
{
  return   &(g_EutraNeighCellConfig[rowId]);
}
 
SysInfo3Config*           getDataSysInfo3ConfigTable( IN RowId rowId )
{
  return   &(g_SysInfo3Config[rowId]);
}
 
SonConfig*                getDataSonConfigTable( IN RowId rowId )
{
  return   &(g_SonConfig[rowId]);
}
 
SrsConfigDedicated*       getDataSrsConfigDedicatedTable( IN RowId rowId )
{
  return   &(g_SrsConfigDedicated[rowId]);
}
 
SecurityConfig*           getDataSecurityConfigTable( IN RowId rowId )
{
  return   &(g_SecurityConfig[rowId]);
}
 
UeEventHistoryLogConfig*  getDataUeEventHistoryLogConfigTable( IN RowId rowId )
{
  return   &(g_UeEventHistoryLogConfig[rowId]);
}
 
CounterConfig*            getDataCounterConfigTable( IN RowId rowId )
{
  return   &(g_CounterConfig[rowId]);
}
 
TraceConfig*              getDataTraceConfigTable( IN RowId rowId )
{
  return   &(g_TraceConfig[rowId]);
}
 
/* GetRow OprConfig */
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill enbRegistrationConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowEnbRegistrationConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_ENBREGISTRATIONCONFIG_TABLE; colId++)
  {
     getElementEnbRegistrationConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill enodebConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowEnodebConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_ENODEBCONFIG_TABLE; colId++)
  {
     getElementEnodebConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill mmeConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowMmeConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_MMECONFIG_TABLE; colId++)
  {
     getElementMmeConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill cellConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowCellConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_CELLCONFIG_TABLE; colId++)
  {
     getElementCellConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill schedulerConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowSchedulerConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_SCHEDULERCONFIG_TABLE; colId++)
  {
     getElementSchedulerConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill phyConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowPhyConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_PHYCONFIG_TABLE; colId++)
  {
     getElementPhyConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo1Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowSysInfo1ConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_SYSINFO1CONFIG_TABLE; colId++)
  {
     getElementSysInfo1ConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo2Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowSysInfo2ConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_SYSINFO2CONFIG_TABLE; colId++)
  {
     getElementSysInfo2ConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill logConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowLogConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_LOGCONFIG_TABLE; colId++)
  {
     getElementLogConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill radioHeadConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowRadioHeadConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_RADIOHEADCONFIG_TABLE; colId++)
  {
     getElementRadioHeadConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill qosConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowQosConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_QOSCONFIG_TABLE; colId++)
  {
     getElementQosConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill pmCounterLogConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowPmCounterLogConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_PMCOUNTERLOGCONFIG_TABLE; colId++)
  {
     getElementPmCounterLogConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill eutraHoProfileConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowEutraHoProfileConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_EUTRAHOPROFILECONFIG_TABLE; colId++)
  {
     getElementEutraHoProfileConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill eutraNeighCellConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowEutraNeighCellConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_EUTRANEIGHCELLCONFIG_TABLE; colId++)
  {
     getElementEutraNeighCellConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo3Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowSysInfo3ConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_SYSINFO3CONFIG_TABLE; colId++)
  {
     getElementSysInfo3ConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sonConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowSonConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_SONCONFIG_TABLE; colId++)
  {
     getElementSonConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill srsConfigDedicated the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowSrsConfigDedicatedTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_SRSCONFIGDEDICATED_TABLE; colId++)
  {
     getElementSrsConfigDedicatedTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill securityConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowSecurityConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_SECURITYCONFIG_TABLE; colId++)
  {
     getElementSecurityConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill ueEventHistoryLogConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowUeEventHistoryLogConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_UEEVENTHISTORYLOGCONFIG_TABLE; colId++)
  {
     getElementUeEventHistoryLogConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill counterConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowCounterConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_COUNTERCONFIG_TABLE; colId++)
  {
     getElementCounterConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill traceConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getRowTraceConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IO TlvArray      *tlvArray
  ) 
{
  ColId   colId=0;
  for (colId=FIRST_COL; colId <= MAX_COLS_IN_TRACECONFIG_TABLE; colId++)
  {
     getElementTraceConfigTable( tableId, rowId-1, colId, tlvArray);
  }
}
 
/* GetElement OprConfig */
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill enbRegistrationConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementEnbRegistrationConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  EnbRegistrationConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_ENBREGISTRATIONCONFIG_BSID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->bsId, tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_PUBLICDNSSERVER1:
      fillTagLenString( tableId, (rowId+1), colId, config->publicDNSServer1, strlen(config->publicDNSServer1), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_PUBLICDNSSERVER2:
      fillTagLenString( tableId, (rowId+1), colId, config->publicDNSServer2, strlen(config->publicDNSServer2), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_PRIVATEDNSSERVER1:
      fillTagLenString( tableId, (rowId+1), colId, config->privateDNSServer1, strlen(config->privateDNSServer1), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_PRIVATEDNSSERVER2:
      fillTagLenString( tableId, (rowId+1), colId, config->privateDNSServer2, strlen(config->privateDNSServer2), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_SECURITYGW1:
      fillTagLenString( tableId, (rowId+1), colId, config->securityGW1, strlen(config->securityGW1), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_SECURITYGW2:
      fillTagLenString( tableId, (rowId+1), colId, config->securityGW2, strlen(config->securityGW2), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_EMSADDR:
      fillTagLenString( tableId, (rowId+1), colId, config->emsAddr, strlen(config->emsAddr), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_CONFIGUREDLATITUDE:
      fillTagLenString( tableId, (rowId+1), colId, config->configuredLatitude, strlen(config->configuredLatitude), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_CONFIGUREDLONGITUDE:
      fillTagLenString( tableId, (rowId+1), colId, config->configuredLongitude, strlen(config->configuredLongitude), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_SNMPCOMMUNITYSTRING:
      fillTagLenString( tableId, (rowId+1), colId, config->snmpCommunityString, strlen(config->snmpCommunityString), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_TIMEANDLOCATIONSOURCETOUSE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->timeAndLocationSourceToUse, tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_INITIALLOCALTIME:
      fillTagLenString( tableId, (rowId+1), colId, config->initialLocalTime, strlen(config->initialLocalTime), tlvArray );
      break;
    case COL_ENBREGISTRATIONCONFIG_INITIALLOCALTIMEOFFSETFROMUTC:
      fillTagLenString( tableId, (rowId+1), colId, config->initialLocalTimeOffsetFromUTC, strlen(config->initialLocalTimeOffsetFromUTC), tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill enodebConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementEnodebConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  EnodebConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_ENODEBCONFIG_ENODEBID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->enodebId, tlvArray );
      break;
    case COL_ENODEBCONFIG_ENODEBNAME:
      fillTagLenString( tableId, (rowId+1), colId, config->enodebName, strlen(config->enodebName), tlvArray );
      break;
    case COL_ENODEBCONFIG_USESTATICIPADDRESS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->useStaticIpAddress, tlvArray );
      break;
    case COL_ENODEBCONFIG_ENODEBSTATICIPADDR:
      fillTagLenString( tableId, (rowId+1), colId, config->enodebStaticIpAddr, strlen(config->enodebStaticIpAddr), tlvArray );
      break;
    case COL_ENODEBCONFIG_ENODEBNETMASKADDR:
      fillTagLenString( tableId, (rowId+1), colId, config->enodebNetmaskAddr, strlen(config->enodebNetmaskAddr), tlvArray );
      break;
    case COL_ENODEBCONFIG_ENODEBREGISTRATIONACCEPTED:
      fillTagLenUint8( tableId, (rowId+1), colId, config->enodebRegistrationAccepted, tlvArray );
      break;
    case COL_ENODEBCONFIG_CONFIGCHANGEACKBYEMS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->configChangeAckByEms, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill mmeConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementMmeConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  MmeConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_MMECONFIG_INDEX:
      fillTagLenUint32( tableId, (rowId+1), colId, config->index, tlvArray );
      break;
    case COL_MMECONFIG_MMEIPADDR:
      fillTagLenString( tableId, (rowId+1), colId, config->mmeIpAddr, strlen(config->mmeIpAddr), tlvArray );
      break;
    case COL_MMECONFIG_ENABLESECUREMMELINK:
      fillTagLenUint8( tableId, (rowId+1), colId, config->enableSecureMmeLink, tlvArray );
      break;
    case COL_MMECONFIG_ENABLESECUREGTPTUNNELS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->enableSecureGtpTunnels, tlvArray );
      break;
    case COL_MMECONFIG_NUMSCTPSTREAMS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->numSctpStreams, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill cellConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementCellConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  CellConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_CELLCONFIG_CELLID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->cellId, tlvArray );
      break;
    case COL_CELLCONFIG_CELLTYPE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->cellType, tlvArray );
      break;
    case COL_CELLCONFIG_PLMNMCC:
      fillTagLenString( tableId, (rowId+1), colId, config->plmnMCC, strlen(config->plmnMCC), tlvArray );
      break;
    case COL_CELLCONFIG_PLMNMNC:
      fillTagLenString( tableId, (rowId+1), colId, config->plmnMNC, strlen(config->plmnMNC), tlvArray );
      break;
    case COL_CELLCONFIG_TAC:
      fillTagLenUint16( tableId, (rowId+1), colId, config->tac, tlvArray );
      break;
    case COL_CELLCONFIG_FREQBANDIND:
      fillTagLenUint8( tableId, (rowId+1), colId, config->freqBandInd, tlvArray );
      break;
    case COL_CELLCONFIG_DLBANDWIDTH:
      fillTagLenUint32( tableId, (rowId+1), colId, config->dlBandwidth, tlvArray );
      break;
    case COL_CELLCONFIG_DLEARFCN:
      fillTagLenUint32( tableId, (rowId+1), colId, config->dlEarfcn, tlvArray );
      break;
    case COL_CELLCONFIG_ULBANDWIDTH:
      fillTagLenUint32( tableId, (rowId+1), colId, config->ulBandwidth, tlvArray );
      break;
    case COL_CELLCONFIG_ULEARFCN:
      fillTagLenUint32( tableId, (rowId+1), colId, config->ulEarfcn, tlvArray );
      break;
    case COL_CELLCONFIG_CELLRESERVEDFOROPERATORUSE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->cellReservedForOperatorUse, tlvArray );
      break;
    case COL_CELLCONFIG_MAXCONNECTEDUES:
      fillTagLenUint16( tableId, (rowId+1), colId, config->maxConnectedUes, tlvArray );
      break;
    case COL_CELLCONFIG_ACBARRINGEMERGENCY:
      fillTagLenUint8( tableId, (rowId+1), colId, config->acBarringEmergency, tlvArray );
      break;
    case COL_CELLCONFIG_ACBARRMOSIGENABLED:
      fillTagLenUint8( tableId, (rowId+1), colId, config->acBarrMoSigEnabled, tlvArray );
      break;
    case COL_CELLCONFIG_ACBARRMOSIGFACTOR:
      fillTagLenUint32( tableId, (rowId+1), colId, config->acBarrMoSigFactor, tlvArray );
      break;
    case COL_CELLCONFIG_ACBARRMOSIGTIME:
      fillTagLenUint32( tableId, (rowId+1), colId, config->acBarrMoSigTime, tlvArray );
      break;
    case COL_CELLCONFIG_ACBARRMOSIGSPECIALAC:
      fillTagLenString( tableId, (rowId+1), colId, config->acBarrMoSigSpecialAC, strlen(config->acBarrMoSigSpecialAC), tlvArray );
      break;
    case COL_CELLCONFIG_ACBARRMODATAENABLED:
      fillTagLenUint8( tableId, (rowId+1), colId, config->acBarrMoDataEnabled, tlvArray );
      break;
    case COL_CELLCONFIG_ACBARRMODATAFACTOR:
      fillTagLenUint32( tableId, (rowId+1), colId, config->acBarrMoDataFactor, tlvArray );
      break;
    case COL_CELLCONFIG_ACBARRMODATATIME:
      fillTagLenUint32( tableId, (rowId+1), colId, config->acBarrMoDataTime, tlvArray );
      break;
    case COL_CELLCONFIG_ACBARRMODATASPECIALAC:
      fillTagLenString( tableId, (rowId+1), colId, config->acBarrMoDataSpecialAC, strlen(config->acBarrMoDataSpecialAC), tlvArray );
      break;
    case COL_CELLCONFIG_STARTRNTI:
      fillTagLenUint16( tableId, (rowId+1), colId, config->startRnti, tlvArray );
      break;
    case COL_CELLCONFIG_RSRPFILTERCOEFFICIENT:
      fillTagLenUint32( tableId, (rowId+1), colId, config->rsrpFilterCoefficient, tlvArray );
      break;
    case COL_CELLCONFIG_SCHEDULERPROFILEID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->schedulerProfileId, tlvArray );
      break;
    case COL_CELLCONFIG_PHYPROFILEID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->phyProfileId, tlvArray );
      break;
    case COL_CELLCONFIG_PHYLAYERID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->phyLayerId, tlvArray );
      break;
    case COL_CELLCONFIG_PHYCELLIDENTITYGROUP:
      fillTagLenUint8( tableId, (rowId+1), colId, config->phyCellIdentityGroup, tlvArray );
      break;
    case COL_CELLCONFIG_PMAX:
      fillTagLenUint8( tableId, (rowId+1), colId, config->pMax, tlvArray );
      break;
    case COL_CELLCONFIG_UERESPONSETIMER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->ueResponseTimer, tlvArray );
      break;
    case COL_CELLCONFIG_RRCCONNREJWAITTIME:
      fillTagLenUint8( tableId, (rowId+1), colId, config->rrcConnRejWaitTime, tlvArray );
      break;
    case COL_CELLCONFIG_UEINACTIVITYCHECKINTERVALSECS:
      fillTagLenUint32( tableId, (rowId+1), colId, config->ueInactivityCheckIntervalSecs, tlvArray );
      break;
    case COL_CELLCONFIG_SYSINFO1PROFILEID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->sysInfo1ProfileId, tlvArray );
      break;
    case COL_CELLCONFIG_SYSINFO2PROFILEID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->sysInfo2ProfileId, tlvArray );
      break;
    case COL_CELLCONFIG_SYSINFO3PROFILEID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->sysInfo3ProfileId, tlvArray );
      break;
    case COL_CELLCONFIG_SIRETXCNT:
      fillTagLenUint8( tableId, (rowId+1), colId, config->siReTxCnt, tlvArray );
      break;
    case COL_CELLCONFIG_ANTINFOTXMODE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->antInfoTxMode, tlvArray );
      break;
    case COL_CELLCONFIG_INITIALULCQI:
      fillTagLenUint8( tableId, (rowId+1), colId, config->initialUlCqi, tlvArray );
      break;
    case COL_CELLCONFIG_PUCCHRESOURCESIZE:
      fillTagLenUint8( tableId, (rowId+1), colId, config->pucchResourceSize, tlvArray );
      break;
    case COL_CELLCONFIG_CQIPERIODICITYIDX:
      fillTagLenUint32( tableId, (rowId+1), colId, config->cqiPeriodicityIdx, tlvArray );
      break;
    case COL_CELLCONFIG_SRIPERIODICITYIDX:
      fillTagLenUint32( tableId, (rowId+1), colId, config->sriPeriodicityIdx, tlvArray );
      break;
    case COL_CELLCONFIG_UECQIBASEDRLFDETECTIONTIMER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->ueCqiBasedRlfDetectionTimer, tlvArray );
      break;
    case COL_CELLCONFIG_UECFGMACCOLLATEDCQICOUNT:
      fillTagLenUint8( tableId, (rowId+1), colId, config->ueCfgMacCollatedCqiCount, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill schedulerConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementSchedulerConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  SchedulerConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_SCHEDULERCONFIG_SCHEDULERPROFILEID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->schedulerProfileId, tlvArray );
      break;
    case COL_SCHEDULERCONFIG_SCHEDULINGALGORITHM:
      fillTagLenUint32( tableId, (rowId+1), colId, config->schedulingAlgorithm, tlvArray );
      break;
    case COL_SCHEDULERCONFIG_MAXDLHARQTX:
      fillTagLenUint8( tableId, (rowId+1), colId, config->maxDlHarqTx, tlvArray );
      break;
    case COL_SCHEDULERCONFIG_MAXULHARQTX:
      fillTagLenUint32( tableId, (rowId+1), colId, config->maxUlHarqTx, tlvArray );
      break;
    case COL_SCHEDULERCONFIG_MAXMSG4HARQTX:
      fillTagLenUint8( tableId, (rowId+1), colId, config->maxMsg4HarqTx, tlvArray );
      break;
    case COL_SCHEDULERCONFIG_PCFICHCFI:
      fillTagLenUint8( tableId, (rowId+1), colId, config->pcfichCfi, tlvArray );
      break;
    case COL_SCHEDULERCONFIG_PERIODICPHRTIMER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->periodicPhrTimer, tlvArray );
      break;
    case COL_SCHEDULERCONFIG_PROHIBITPHRTIMER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->prohibitPhrTimer, tlvArray );
      break;
    case COL_SCHEDULERCONFIG_DLPATHLOSSCHANGE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->dlPathlossChange, tlvArray );
      break;
    case COL_SCHEDULERCONFIG_PERIODICBSRTIMER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->periodicBsrTimer, tlvArray );
      break;
    case COL_SCHEDULERCONFIG_RETXBSRTIMER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->retxBsrTimer, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill phyConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementPhyConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  PhyConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_PHYCONFIG_PHYPROFILEID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->phyProfileId, tlvArray );
      break;
    case COL_PHYCONFIG_PHICHRESOURCE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->phichResource, tlvArray );
      break;
    case COL_PHYCONFIG_PRACHFREQOFFSET:
      fillTagLenUint8( tableId, (rowId+1), colId, config->prachFreqOffset, tlvArray );
      break;
    case COL_PHYCONFIG_REFERENCESIGNALPOWER:
      fillTagLenUint8( tableId, (rowId+1), colId, config->referenceSignalPower, tlvArray );
      break;
    case COL_PHYCONFIG_CELLPHYPB:
      fillTagLenUint8( tableId, (rowId+1), colId, config->cellPhyPb, tlvArray );
      break;
    case COL_PHYCONFIG_SRSENABLED:
      fillTagLenUint8( tableId, (rowId+1), colId, config->srsEnabled, tlvArray );
      break;
    case COL_PHYCONFIG_ALPHA:
      fillTagLenUint32( tableId, (rowId+1), colId, config->alpha, tlvArray );
      break;
    case COL_PHYCONFIG_PONOMINALPUCCH:
      fillTagLenUint8( tableId, (rowId+1), colId, config->poNominalPucch, tlvArray );
      break;
    case COL_PHYCONFIG_CELLPHYPA:
      fillTagLenUint32( tableId, (rowId+1), colId, config->cellPhyPa, tlvArray );
      break;
    case COL_PHYCONFIG_BETAOFFSETACKINDEX:
      fillTagLenUint8( tableId, (rowId+1), colId, config->betaOffsetAckIndex, tlvArray );
      break;
    case COL_PHYCONFIG_BETAOFFSETRIINDEX:
      fillTagLenUint8( tableId, (rowId+1), colId, config->betaOffsetRiIndex, tlvArray );
      break;
    case COL_PHYCONFIG_BETAOFFSETCQIINDEX:
      fillTagLenUint8( tableId, (rowId+1), colId, config->betaOffsetCqiIndex, tlvArray );
      break;
    case COL_PHYCONFIG_POUEPUSCH:
      fillTagLenUint8( tableId, (rowId+1), colId, config->poUePusch, tlvArray );
      break;
    case COL_PHYCONFIG_POUEPUCCH:
      fillTagLenUint8( tableId, (rowId+1), colId, config->poUePucch, tlvArray );
      break;
    case COL_PHYCONFIG_PSRSOFFSET:
      fillTagLenUint8( tableId, (rowId+1), colId, config->pSrsOffset, tlvArray );
      break;
    case COL_PHYCONFIG_PHICHDURATION:
      fillTagLenUint32( tableId, (rowId+1), colId, config->phichDuration, tlvArray );
      break;
    case COL_PHYCONFIG_TOTALTXPOWER:
      fillTagLenUint8( tableId, (rowId+1), colId, config->totalTxPower, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo1Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementSysInfo1ConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  SysInfo1Config  *config = getData(rowId);

  switch(colId)
  {
    case COL_SYSINFO1CONFIG_SYSINFO1PROFILEID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->sysInfo1ProfileId, tlvArray );
      break;
    case COL_SYSINFO1CONFIG_INTRAFREQRESELECTION:
      fillTagLenUint32( tableId, (rowId+1), colId, config->intraFreqReselection, tlvArray );
      break;
    case COL_SYSINFO1CONFIG_QRXLEVMIN:
      fillTagLenUint8( tableId, (rowId+1), colId, config->qRxLevMin, tlvArray );
      break;
    case COL_SYSINFO1CONFIG_QRXLEVMINOFFSET:
      fillTagLenUint8( tableId, (rowId+1), colId, config->qRxLevMinOffset, tlvArray );
      break;
    case COL_SYSINFO1CONFIG_SIB2PERIODICITY:
      fillTagLenUint32( tableId, (rowId+1), colId, config->sib2Periodicity, tlvArray );
      break;
    case COL_SYSINFO1CONFIG_SIB3PERIODICITY:
      fillTagLenUint32( tableId, (rowId+1), colId, config->sib3Periodicity, tlvArray );
      break;
    case COL_SYSINFO1CONFIG_SIB4PERIODICITY:
      fillTagLenUint32( tableId, (rowId+1), colId, config->sib4Periodicity, tlvArray );
      break;
    case COL_SYSINFO1CONFIG_SIWINDOWLENGTH:
      fillTagLenUint32( tableId, (rowId+1), colId, config->siWindowLength, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo2Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementSysInfo2ConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  SysInfo2Config  *config = getData(rowId);

  switch(colId)
  {
    case COL_SYSINFO2CONFIG_SYSINFO2PROFILEID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->sysInfo2ProfileId, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_NUMRAPREAMBLES:
      fillTagLenUint32( tableId, (rowId+1), colId, config->numRaPreambles, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_SIZERAPREAMBLESGROUPA:
      fillTagLenUint32( tableId, (rowId+1), colId, config->sizeRAPreamblesGroupA, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_MESSAGESIZEGROUPA:
      fillTagLenUint32( tableId, (rowId+1), colId, config->messageSizeGroupA, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_MESSAGEPOWEROFFSETGROUPB:
      fillTagLenUint32( tableId, (rowId+1), colId, config->messagePowerOffsetGroupB, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_POWERRAMPINGSTEP:
      fillTagLenUint32( tableId, (rowId+1), colId, config->powerRampingStep, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_PREAMBLEINITRCVDTGTPOWER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->preambleInitRcvdTgtPower, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_PREAMBLETRANSMAX:
      fillTagLenUint32( tableId, (rowId+1), colId, config->preambleTransMax, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_RARSPWINDOWSIZE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->raRspWindowSize, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_MACCONTRESOLUTIONTIMER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->macContResolutionTimer, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_MAXHARQMSG3TX:
      fillTagLenUint8( tableId, (rowId+1), colId, config->maxHarqMsg3Tx, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_MODIFICATIONPERIODCOEFF:
      fillTagLenUint32( tableId, (rowId+1), colId, config->modificationPeriodCoeff, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_DEFAULTPAGCYCLE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->defaultPagCycle, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_NB:
      fillTagLenUint32( tableId, (rowId+1), colId, config->nB, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_ROOTSEQUENCEINDEX:
      fillTagLenUint16( tableId, (rowId+1), colId, config->rootSequenceIndex, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_PRACHCONFIGINDEX:
      fillTagLenUint8( tableId, (rowId+1), colId, config->prachConfigIndex, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_HIGHSPEEDFLAG:
      fillTagLenUint8( tableId, (rowId+1), colId, config->highSpeedFlag, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_ZEROCORRELATIONZONECONFIG:
      fillTagLenUint8( tableId, (rowId+1), colId, config->zeroCorrelationZoneConfig, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_PUSCHFREQHOPPINGSUBBANDS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->puschFreqHoppingSubBands, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_PUSCHFREQHOPPINGMODE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->puschFreqHoppingMode, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_PUSCHFREQHOPPINGOFFSET:
      fillTagLenUint8( tableId, (rowId+1), colId, config->puschFreqHoppingOffset, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_ULRSGROUPHOPPINGENABLED:
      fillTagLenUint8( tableId, (rowId+1), colId, config->ulRsGroupHoppingEnabled, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_ULRSGROUPPUSCH:
      fillTagLenUint8( tableId, (rowId+1), colId, config->ulRsGroupPusch, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_ULRSSEQHOPPINGENABLED:
      fillTagLenUint8( tableId, (rowId+1), colId, config->ulRsSeqHoppingEnabled, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_ULRSCYCLICSHIFTPUSCH:
      fillTagLenUint8( tableId, (rowId+1), colId, config->ulRsCyclicShiftPusch, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_DELTAPUCCHSHIFT:
      fillTagLenUint32( tableId, (rowId+1), colId, config->deltaPucchShift, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_N1PUCCHAN:
      fillTagLenUint16( tableId, (rowId+1), colId, config->n1PucchAn, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_SRSBANDWIDTHCONFIG:
      fillTagLenUint32( tableId, (rowId+1), colId, config->srsBandwidthConfig, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_SRSSUBFRMCONFIG:
      fillTagLenUint32( tableId, (rowId+1), colId, config->srsSubfrmConfig, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_SRSSIMULTANEOUSANSRSTX:
      fillTagLenUint8( tableId, (rowId+1), colId, config->srsSimultaneousAnSrsTx, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_PONOMINALPUSCH:
      fillTagLenUint8( tableId, (rowId+1), colId, config->poNominalPusch, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_DELTAFPUCCHFORMAT1:
      fillTagLenUint32( tableId, (rowId+1), colId, config->deltaFPucchFormat1, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_DELTAFPUCCHFORMAT1B:
      fillTagLenUint32( tableId, (rowId+1), colId, config->deltaFPucchFormat1b, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_DELTAFPUCCHFORMAT2:
      fillTagLenUint32( tableId, (rowId+1), colId, config->deltaFPucchFormat2, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_DELTAFPUCCHFORMAT2A:
      fillTagLenUint32( tableId, (rowId+1), colId, config->deltaFPucchFormat2a, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_DELTAFPUCCHFORMAT2B:
      fillTagLenUint32( tableId, (rowId+1), colId, config->deltaFPucchFormat2b, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_DELTAPREAMBLEMSG3:
      fillTagLenUint8( tableId, (rowId+1), colId, config->deltaPreambleMsg3, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_T300:
      fillTagLenUint32( tableId, (rowId+1), colId, config->t300, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_T301:
      fillTagLenUint32( tableId, (rowId+1), colId, config->t301, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_T310:
      fillTagLenUint32( tableId, (rowId+1), colId, config->t310, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_N310:
      fillTagLenUint32( tableId, (rowId+1), colId, config->n310, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_T311:
      fillTagLenUint32( tableId, (rowId+1), colId, config->t311, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_N311:
      fillTagLenUint32( tableId, (rowId+1), colId, config->n311, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_ADDITIONALSPECTRUMEMISSION:
      fillTagLenUint8( tableId, (rowId+1), colId, config->additionalSpectrumEmission, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_TIMEALIGNMENTTIMER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->timeAlignmentTimer, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_NRBCQI:
      fillTagLenUint8( tableId, (rowId+1), colId, config->nRbCqi, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_ENABLE64QAM:
      fillTagLenUint8( tableId, (rowId+1), colId, config->enable64QAM, tlvArray );
      break;
    case COL_SYSINFO2CONFIG_NCSAN:
      fillTagLenUint8( tableId, (rowId+1), colId, config->nCsAn, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill logConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementLogConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  LogConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_LOGCONFIG_MODULEID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->moduleId, tlvArray );
      break;
    case COL_LOGCONFIG_LOGMASK1:
      fillTagLenUint32( tableId, (rowId+1), colId, config->logMask1, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill radioHeadConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementRadioHeadConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  RadioHeadConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_RADIOHEADCONFIG_RADIOHEADPROFILEID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->radioHeadProfileId, tlvArray );
      break;
    case COL_RADIOHEADCONFIG_TXATTENPATHA:
      fillTagLenUint16( tableId, (rowId+1), colId, config->txAttenPathA, tlvArray );
      break;
    case COL_RADIOHEADCONFIG_TXATTENPATHB:
      fillTagLenUint16( tableId, (rowId+1), colId, config->txAttenPathB, tlvArray );
      break;
    case COL_RADIOHEADCONFIG_TXDELAY:
      fillTagLenUint32( tableId, (rowId+1), colId, config->txDelay, tlvArray );
      break;
    case COL_RADIOHEADCONFIG_RXDELAY:
      fillTagLenUint32( tableId, (rowId+1), colId, config->rxDelay, tlvArray );
      break;
    case COL_RADIOHEADCONFIG_VSWRSHUTDOWNALARMTHRESHOLD:
      fillTagLenUint8( tableId, (rowId+1), colId, config->vswrShutdownAlarmThreshold, tlvArray );
      break;
    case COL_RADIOHEADCONFIG_OVERPOWERALARMTHRESHOLD:
      fillTagLenUint32( tableId, (rowId+1), colId, config->overpowerAlarmThreshold, tlvArray );
      break;
    case COL_RADIOHEADCONFIG_LOWPOWERALARMTHRESHOLD:
      fillTagLenUint32( tableId, (rowId+1), colId, config->lowpowerAlarmThreshold, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill qosConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementQosConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  QosConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_QOSCONFIG_QOSPROFILEID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->qosProfileId, tlvArray );
      break;
    case COL_QOSCONFIG_QOSPROFILENAME:
      fillTagLenString( tableId, (rowId+1), colId, config->qosProfileName, strlen(config->qosProfileName), tlvArray );
      break;
    case COL_QOSCONFIG_QCI:
      fillTagLenUint8( tableId, (rowId+1), colId, config->qci, tlvArray );
      break;
    case COL_QOSCONFIG_RLCMODE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->rlcMode, tlvArray );
      break;
    case COL_QOSCONFIG_AMRLCTPOLLRETRANSMIT:
      fillTagLenUint32( tableId, (rowId+1), colId, config->amRlcTPollRetransmit, tlvArray );
      break;
    case COL_QOSCONFIG_AMRLCPOLLPDU:
      fillTagLenUint32( tableId, (rowId+1), colId, config->amRlcPollPDU, tlvArray );
      break;
    case COL_QOSCONFIG_AMRLCPOLLBYTE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->amRlcPollByte, tlvArray );
      break;
    case COL_QOSCONFIG_AMRLCMAXRETXTHRESHOLD:
      fillTagLenUint32( tableId, (rowId+1), colId, config->amRlcMaxRetxThreshold, tlvArray );
      break;
    case COL_QOSCONFIG_AMRLCTREORDERING:
      fillTagLenUint32( tableId, (rowId+1), colId, config->amRlcTReordering, tlvArray );
      break;
    case COL_QOSCONFIG_AMRLCTSTATUSPROHIBIT:
      fillTagLenUint32( tableId, (rowId+1), colId, config->amRlcTStatusProhibit, tlvArray );
      break;
    case COL_QOSCONFIG_DISCARDTIMER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->discardTimer, tlvArray );
      break;
    case COL_QOSCONFIG_STATUSREPORTREQUIRED:
      fillTagLenUint8( tableId, (rowId+1), colId, config->statusReportRequired, tlvArray );
      break;
    case COL_QOSCONFIG_DRBPRIORITY:
      fillTagLenUint8( tableId, (rowId+1), colId, config->drbPriority, tlvArray );
      break;
    case COL_QOSCONFIG_DRBPRIORITISEDBITRATE:
      fillTagLenUint32( tableId, (rowId+1), colId, config->drbPrioritisedBitRate, tlvArray );
      break;
    case COL_QOSCONFIG_DRBBUCKETSIZEDURATION:
      fillTagLenUint32( tableId, (rowId+1), colId, config->drbBucketSizeDuration, tlvArray );
      break;
    case COL_QOSCONFIG_LOGICALCHANNELGROUP:
      fillTagLenUint8( tableId, (rowId+1), colId, config->logicalChannelGroup, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill pmCounterLogConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementPmCounterLogConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  PmCounterLogConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_PMCOUNTERLOGCONFIG_PMPROFILEID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->pmProfileId, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_SAMPLEINTERVAL:
      fillTagLenUint32( tableId, (rowId+1), colId, config->sampleInterval, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_PMFILECREATIONINTERVAL:
      fillTagLenUint32( tableId, (rowId+1), colId, config->pmFileCreationInterval, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTMACGENCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectMacGenCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTMACUPLANECOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectMacUplaneCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTRLCGENCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectRlcGenCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTPDCPGENCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectPdcpGenCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTPDCPUPLANECOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectPdcpUplaneCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTGTPGENCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectGtpGenCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTSCTPGENCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectSctpGenCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTS1APGENCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectS1apGenCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTS1APPEERNODECOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectS1apPeerNodeCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTRRCGENCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectRrcGenCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTRRCCELLCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectRrcCellCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTRRMCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectRrmCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTIPCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectIPCounters, tlvArray );
      break;
    case COL_PMCOUNTERLOGCONFIG_COLLECTETHERNETCOUNTERS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->collectEthernetCounters, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill eutraHoProfileConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementEutraHoProfileConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  EutraHoProfileConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_EUTRAHOPROFILECONFIG_HOPROFILEID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->hoProfileId, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_A3OFFSET:
      fillTagLenUint8( tableId, (rowId+1), colId, config->a3Offset, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_REPORTONLEAVE:
      fillTagLenUint8( tableId, (rowId+1), colId, config->reportOnLeave, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_A5THRESHOLD1:
      fillTagLenUint8( tableId, (rowId+1), colId, config->a5Threshold1, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_A5THRESHOLD2:
      fillTagLenUint8( tableId, (rowId+1), colId, config->a5Threshold2, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_HYSTERESIS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->hysteresis, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_TIMETOTRIGGER:
      fillTagLenUint32( tableId, (rowId+1), colId, config->timeToTrigger, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_TRIGGERQUANTITY:
      fillTagLenUint32( tableId, (rowId+1), colId, config->triggerQuantity, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_REPORTQUANTITY:
      fillTagLenUint32( tableId, (rowId+1), colId, config->reportQuantity, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_FILTERCOEFFICIENTRSRQ:
      fillTagLenUint32( tableId, (rowId+1), colId, config->filterCoefficientRsrq, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_FILTERCOEFFICIENTRSRP:
      fillTagLenUint32( tableId, (rowId+1), colId, config->filterCoefficientRsrp, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_REPORTINTERVAL:
      fillTagLenUint32( tableId, (rowId+1), colId, config->reportInterval, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_REPORTAMOUNT:
      fillTagLenUint32( tableId, (rowId+1), colId, config->reportAmount, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_MAXREPORTCELLS:
      fillTagLenUint8( tableId, (rowId+1), colId, config->maxReportCells, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_SUPPORTEDEVENTS:
      fillTagLenUint32( tableId, (rowId+1), colId, config->supportedEvents, tlvArray );
      break;
    case COL_EUTRAHOPROFILECONFIG_SMEASURE:
      fillTagLenUint8( tableId, (rowId+1), colId, config->sMeasure, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill eutraNeighCellConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementEutraNeighCellConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  EutraNeighCellConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_EUTRANEIGHCELLCONFIG_NEIBOURINDEX:
      fillTagLenUint32( tableId, (rowId+1), colId, config->neibourIndex, tlvArray );
      break;
    case COL_EUTRANEIGHCELLCONFIG_ISUSED:
      fillTagLenUint8( tableId, (rowId+1), colId, config->isUsed, tlvArray );
      break;
    case COL_EUTRANEIGHCELLCONFIG_NEIGHEUTRAENBID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->neighEutraEnbId, tlvArray );
      break;
    case COL_EUTRANEIGHCELLCONFIG_NEIGHEUTRACELLID:
      fillTagLenUint8( tableId, (rowId+1), colId, config->neighEutraCellId, tlvArray );
      break;
    case COL_EUTRANEIGHCELLCONFIG_NEIGHEUTRAPHYCELLID:
      fillTagLenUint16( tableId, (rowId+1), colId, config->neighEutraPhyCellId, tlvArray );
      break;
    case COL_EUTRANEIGHCELLCONFIG_NEIGHEUTRAPLMNMCC:
      fillTagLenString( tableId, (rowId+1), colId, config->neighEutraPlmnMcc, strlen(config->neighEutraPlmnMcc), tlvArray );
      break;
    case COL_EUTRANEIGHCELLCONFIG_NEIGHEUTRAPLMNMNC:
      fillTagLenString( tableId, (rowId+1), colId, config->neighEutraPlmnMnc, strlen(config->neighEutraPlmnMnc), tlvArray );
      break;
    case COL_EUTRANEIGHCELLCONFIG_NEIGHEUTRATAC:
      fillTagLenUint16( tableId, (rowId+1), colId, config->neighEutraTac, tlvArray );
      break;
    case COL_EUTRANEIGHCELLCONFIG_NEIGHCELLMEASBANDWIDTH:
      fillTagLenUint32( tableId, (rowId+1), colId, config->neighCellMeasBandwidth, tlvArray );
      break;
    case COL_EUTRANEIGHCELLCONFIG_CELLINDIVIDUALOFFSET:
      fillTagLenUint32( tableId, (rowId+1), colId, config->cellIndividualOffset, tlvArray );
      break;
    case COL_EUTRANEIGHCELLCONFIG_INTRAFREQNEIGHCELLQOFFSETCELL:
      fillTagLenUint32( tableId, (rowId+1), colId, config->intraFreqNeighCellQOffsetCell, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo3Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementSysInfo3ConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  SysInfo3Config  *config = getData(rowId);

  switch(colId)
  {
    case COL_SYSINFO3CONFIG_SYSINFO3PROFILEID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->sysInfo3ProfileId, tlvArray );
      break;
    case COL_SYSINFO3CONFIG_QHYST:
      fillTagLenUint32( tableId, (rowId+1), colId, config->qHyst, tlvArray );
      break;
    case COL_SYSINFO3CONFIG_THRESHSERVINGLOW:
      fillTagLenUint8( tableId, (rowId+1), colId, config->threshServingLow, tlvArray );
      break;
    case COL_SYSINFO3CONFIG_CELLRESELECTIONPRIORITY:
      fillTagLenUint8( tableId, (rowId+1), colId, config->cellReselectionPriority, tlvArray );
      break;
    case COL_SYSINFO3CONFIG_QRXLEVMIN:
      fillTagLenUint8( tableId, (rowId+1), colId, config->qRxLevMin, tlvArray );
      break;
    case COL_SYSINFO3CONFIG_PMAX:
      fillTagLenUint8( tableId, (rowId+1), colId, config->pMax, tlvArray );
      break;
    case COL_SYSINFO3CONFIG_SINTRASEARCH:
      fillTagLenUint8( tableId, (rowId+1), colId, config->sIntraSearch, tlvArray );
      break;
    case COL_SYSINFO3CONFIG_ALLOWMEASBW:
      fillTagLenUint32( tableId, (rowId+1), colId, config->allowMeasBw, tlvArray );
      break;
    case COL_SYSINFO3CONFIG_NEIGHCELLCONFIG:
      fillTagLenUint8( tableId, (rowId+1), colId, config->neighCellConfig, tlvArray );
      break;
    case COL_SYSINFO3CONFIG_TRESELECTIONEUTRA:
      fillTagLenUint8( tableId, (rowId+1), colId, config->tReselectionEutra, tlvArray );
      break;
    case COL_SYSINFO3CONFIG_PRESENCEANTENNAPORT1:
      fillTagLenUint8( tableId, (rowId+1), colId, config->presenceAntennaPort1, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sonConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementSonConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  SonConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_SONCONFIG_SONPROFILEID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->sonProfileId, tlvArray );
      break;
    case COL_SONCONFIG_INTRAFREQHOTHRESHOLD:
      fillTagLenUint8( tableId, (rowId+1), colId, config->intraFreqHoThreshold, tlvArray );
      break;
    case COL_SONCONFIG_ICICTHRESHOLD:
      fillTagLenUint8( tableId, (rowId+1), colId, config->icicThreshold, tlvArray );
      break;
    case COL_SONCONFIG_UELOADCHANGETHRESHOLD:
      fillTagLenUint8( tableId, (rowId+1), colId, config->ueLoadChangeThreshold, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill srsConfigDedicated the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementSrsConfigDedicatedTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  SrsConfigDedicated  *config = getData(rowId);

  switch(colId)
  {
    case COL_SRSCONFIGDEDICATED_SRSBANDWIDTH:
      fillTagLenUint32( tableId, (rowId+1), colId, config->srsBandwidth, tlvArray );
      break;
    case COL_SRSCONFIGDEDICATED_SRSHOPPINGBANDWIDTH:
      fillTagLenUint32( tableId, (rowId+1), colId, config->srsHoppingBandWidth, tlvArray );
      break;
    case COL_SRSCONFIGDEDICATED_FREQUECYDOMAINPOSITION:
      fillTagLenUint8( tableId, (rowId+1), colId, config->frequecyDomainPosition, tlvArray );
      break;
    case COL_SRSCONFIGDEDICATED_DURATION:
      fillTagLenUint8( tableId, (rowId+1), colId, config->duration, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill securityConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementSecurityConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  SecurityConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_SECURITYCONFIG_INDEX:
      fillTagLenUint32( tableId, (rowId+1), colId, config->index, tlvArray );
      break;
    case COL_SECURITYCONFIG_UUCIPHERING:
      fillTagLenUint32( tableId, (rowId+1), colId, config->uuCiphering, tlvArray );
      break;
    case COL_SECURITYCONFIG_UUINTEGRITYPROTECTION:
      fillTagLenUint32( tableId, (rowId+1), colId, config->uuIntegrityProtection, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill ueEventHistoryLogConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementUeEventHistoryLogConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  UeEventHistoryLogConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_UEEVENTHISTORYLOGCONFIG_UEEVENTHISTORYINDEX:
      fillTagLenUint32( tableId, (rowId+1), colId, config->ueEventHistoryIndex, tlvArray );
      break;
    case COL_UEEVENTHISTORYLOGCONFIG_CRNTI:
      fillTagLenUint16( tableId, (rowId+1), colId, config->cRnti, tlvArray );
      break;
    case COL_UEEVENTHISTORYLOGCONFIG_UEPROCEDUREBITMAP:
      fillTagLenUint8( tableId, (rowId+1), colId, config->ueProcedureBitMap, tlvArray );
      break;
    case COL_UEEVENTHISTORYLOGCONFIG_UEEVENTMEASURES:
      fillTagLenUint32( tableId, (rowId+1), colId, config->ueEventMeasures, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill counterConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementCounterConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  CounterConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_COUNTERCONFIG_INDEX:
      fillTagLenUint32( tableId, (rowId+1), colId, config->index, tlvArray );
      break;
    case COL_COUNTERCONFIG_COUNTERID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->counterId, tlvArray );
      break;
    case COL_COUNTERCONFIG_PROFILEID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->profileId, tlvArray );
      break;
    case COL_COUNTERCONFIG_ISENABLED:
      fillTagLenUint8( tableId, (rowId+1), colId, config->isEnabled, tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/**
 * @param tableId    Table ID
 * @param rowId      Row ID
 * @param colId      Column ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill traceConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getElementTraceConfigTable(
  IN TableId        tableId,
  IN RowId          rowId,
  IN ColId          colId,
  IO TlvArray      *tlvArray
  ) 
{
  DataHdlr      getData = g_OprCfgTable[tableId-MIN_OPR_CFG_TABLEID].getData;
  TraceConfig  *config = getData(rowId);

  switch(colId)
  {
    case COL_TRACECONFIG_TRACEPROFILEID:
      fillTagLenUint32( tableId, (rowId+1), colId, config->traceProfileId, tlvArray );
      break;
    case COL_TRACECONFIG_TRACERRC:
      fillTagLenUint8( tableId, (rowId+1), colId, config->traceRRC, tlvArray );
      break;
    case COL_TRACECONFIG_TRACES1AP:
      fillTagLenUint8( tableId, (rowId+1), colId, config->traceS1AP, tlvArray );
      break;
    case COL_TRACECONFIG_TRACEX2AP:
      fillTagLenUint8( tableId, (rowId+1), colId, config->traceX2AP, tlvArray );
      break;
    case COL_TRACECONFIG_TRACERESERVED1:
      fillTagLenUint8( tableId, (rowId+1), colId, config->traceReserved1, tlvArray );
      break;
    case COL_TRACECONFIG_TRACERESERVED2:
      fillTagLenUint8( tableId, (rowId+1), colId, config->traceReserved2, tlvArray );
      break;
    case COL_TRACECONFIG_TRACERESERVED3:
      fillTagLenUint8( tableId, (rowId+1), colId, config->traceReserved3, tlvArray );
      break;
    case COL_TRACECONFIG_TRACEDESTINATION:
      fillTagLenUint32( tableId, (rowId+1), colId, config->traceDestination, tlvArray );
      break;
    case COL_TRACECONFIG_TRACEDESTUDPPORT:
      fillTagLenUint16( tableId, (rowId+1), colId, config->traceDestUdpPort, tlvArray );
      break;
    case COL_TRACECONFIG_TRACEDESTIPADDRESS:
      fillTagLenString( tableId, (rowId+1), colId, config->traceDestIPAddress, strlen(config->traceDestIPAddress), tlvArray );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( tableId, (rowId+1), colId );
      break;
  }
}
/* GetTable OprConfig */
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill enbRegistrationConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableEnbRegistrationConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_ENBREGISTRATIONCONFIG_TABLE; rowId++)
  {
     getRowEnbRegistrationConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill enodebConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableEnodebConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_ENODEBCONFIG_TABLE; rowId++)
  {
     getRowEnodebConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill mmeConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableMmeConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_MMECONFIG_TABLE; rowId++)
  {
     getRowMmeConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill cellConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableCellConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_CELLCONFIG_TABLE; rowId++)
  {
     getRowCellConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill schedulerConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableSchedulerConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_SCHEDULERCONFIG_TABLE; rowId++)
  {
     getRowSchedulerConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill phyConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTablePhyConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_PHYCONFIG_TABLE; rowId++)
  {
     getRowPhyConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo1Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableSysInfo1ConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_SYSINFO1CONFIG_TABLE; rowId++)
  {
     getRowSysInfo1ConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo2Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableSysInfo2ConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_SYSINFO2CONFIG_TABLE; rowId++)
  {
     getRowSysInfo2ConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill logConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableLogConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_LOGCONFIG_TABLE; rowId++)
  {
     getRowLogConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill radioHeadConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableRadioHeadConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_RADIOHEADCONFIG_TABLE; rowId++)
  {
     getRowRadioHeadConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill qosConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableQosConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_QOSCONFIG_TABLE; rowId++)
  {
     getRowQosConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill pmCounterLogConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTablePmCounterLogConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_PMCOUNTERLOGCONFIG_TABLE; rowId++)
  {
     getRowPmCounterLogConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill eutraHoProfileConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableEutraHoProfileConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_EUTRAHOPROFILECONFIG_TABLE; rowId++)
  {
     getRowEutraHoProfileConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill eutraNeighCellConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableEutraNeighCellConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_EUTRANEIGHCELLCONFIG_TABLE; rowId++)
  {
     getRowEutraNeighCellConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo3Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableSysInfo3ConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_SYSINFO3CONFIG_TABLE; rowId++)
  {
     getRowSysInfo3ConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sonConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableSonConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_SONCONFIG_TABLE; rowId++)
  {
     getRowSonConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill srsConfigDedicated the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableSrsConfigDedicatedTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_SRSCONFIGDEDICATED_TABLE; rowId++)
  {
     getRowSrsConfigDedicatedTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill securityConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableSecurityConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_SECURITYCONFIG_TABLE; rowId++)
  {
     getRowSecurityConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill ueEventHistoryLogConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableUeEventHistoryLogConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_UEEVENTHISTORYLOGCONFIG_TABLE; rowId++)
  {
     getRowUeEventHistoryLogConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill counterConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableCounterConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_COUNTERCONFIG_TABLE; rowId++)
  {
     getRowCounterConfigTable( tableId, rowId, tlvArray);
  }
}
 
/**
 * @param tableId    Table ID
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill traceConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void getTableTraceConfigTable(
  IN TableId        tableId,
  IO TlvArray      *tlvArray
  ) 
{
  RowId   rowId=0;
  for (rowId=FIRST_ROW; rowId <= MAX_ROWS_IN_TRACECONFIG_TABLE; rowId++)
  {
     getRowTraceConfigTable( tableId, rowId, tlvArray);
  }
}
 
/* struct2Tlv OprConfig */
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill enbRegistrationConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvEnbRegistrationConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill enodebConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvEnodebConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill mmeConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvMmeConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill cellConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvCellConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill schedulerConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvSchedulerConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill phyConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvPhyConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo1Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvSysInfo1ConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo2Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvSysInfo2ConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill logConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvLogConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill radioHeadConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvRadioHeadConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill qosConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvQosConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill pmCounterLogConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvPmCounterLogConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill eutraHoProfileConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvEutraHoProfileConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill eutraNeighCellConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvEutraNeighCellConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sysInfo3Config the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvSysInfo3ConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill sonConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvSonConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill srsConfigDedicated the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvSrsConfigDedicatedTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill securityConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvSecurityConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill ueEventHistoryLogConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvUeEventHistoryLogConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill counterConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvCounterConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/**
 * @param tagInfo      TagInfo
 * @param tlvArray     Array of TLV in which Response will be filled.
 * @section This function will get and fill traceConfig the tableId.RowId.Colid information and fill the response TLV.
 * */
void struct2TlvTraceConfigTable(
  IO TagInfo       *tagInfo,
  IO TlvArray      *tlvArray
  ) 
{
  GetCmdType      cmdType;
  cmdType = getCmdType(tagInfo);
  
  switch( cmdType )
  {
    case GET_TABLE:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getTableFunc( tagInfo->tableId, tlvArray );
      break;
    case GET_ROW:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getRowFunc( tagInfo->tableId, tagInfo->rowId, tlvArray );
      break;
    case GET_ELEMENT:
      g_OprCfgTable[tagInfo->tableId-MIN_OPR_CFG_TABLEID].getElementFunc( tagInfo->tableId, tagInfo->rowId - 1, tagInfo->colId, tlvArray );
      break;
    default:
      /* Error Condition */
      break;
  }
}
/* Extern Global Variables OprConfig */

