/**
 * @file    noti_msg_get_set.c
 * @section Copyright Powerwave Technologies, Inc., 2010
 * @section This is auto generated file from Excel
 * @section This file contains GET functions for all tables
 *
 * Author: Madhusudana Rao Kata
 * Date: 28-12-2010
 * Description: Draft version 
 * Generated on : 2/15/2013 2:48:54 PM
 */

 
#include "noti_msg_get_set.h"

/*******************************************************************/
/*****************    ALARM STRUCTURES GET FUNCTIONS   *************/
/*******************************************************************/

/* Struct2Tlv   */
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get alarmNotification the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvAlarmNotification(
  IO MsgBsmSihAlarmNotification                  *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_ALARMNOTIFICATION_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_ALARMNOTIFICATION_STRUCT ; colId ++)
  {
    getElementAlarmNotification( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get mmeReset the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvMmeReset(
  IO MsgBsmSihMmeReset                           *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_MMERESET_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_MMERESET_STRUCT ; colId ++)
  {
    getElementMmeReset( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get fileUploadCompleted the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvFileUploadCompleted(
  IO MsgBsmSihFileUploadCompleted                *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_FILEUPLOADCOMPLETED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_FILEUPLOADCOMPLETED_STRUCT ; colId ++)
  {
    getElementFileUploadCompleted( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get fileUploadFailed the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvFileUploadFailed(
  IO MsgBsmSihFileUploadFailed                   *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_FILEUPLOADFAILED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_FILEUPLOADFAILED_STRUCT ; colId ++)
  {
    getElementFileUploadFailed( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get fileDownloadCompleted the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvFileDownloadCompleted(
  IO MsgBsmSihFileDownloadCompleted              *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_FILEDOWNLOADCOMPLETED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_FILEDOWNLOADCOMPLETED_STRUCT ; colId ++)
  {
    getElementFileDownloadCompleted( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get fileDownloadFailed the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvFileDownloadFailed(
  IO MsgBsmSihFileDownloadFailed                 *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_FILEDOWNLOADFAILED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_FILEDOWNLOADFAILED_STRUCT ; colId ++)
  {
    getElementFileDownloadFailed( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get messageTraceCompleted the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvMessageTraceCompleted(
  IO MsgBsmSihMessageTraceCompleted              *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_MESSAGETRACECOMPLETED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_MESSAGETRACECOMPLETED_STRUCT ; colId ++)
  {
    getElementMessageTraceCompleted( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get messageTraceFailed the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvMessageTraceFailed(
  IO MsgBsmSihMessageTraceFailed                 *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_MESSAGETRACEFAILED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_MESSAGETRACEFAILED_STRUCT ; colId ++)
  {
    getElementMessageTraceFailed( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get counterFileAvailable the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvCounterFileAvailable(
  IO MsgBsmSihCounterFileAvailable               *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_COUNTERFILEAVAILABLE_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_COUNTERFILEAVAILABLE_STRUCT ; colId ++)
  {
    getElementCounterFileAvailable( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get counterCollectionFailed the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvCounterCollectionFailed(
  IO MsgBsmSihCounterCollectionFailed            *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_COUNTERCOLLECTIONFAILED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_COUNTERCOLLECTIONFAILED_STRUCT ; colId ++)
  {
    getElementCounterCollectionFailed( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get configurationChanged the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvConfigurationChanged(
  IO MsgBsmSihConfigurationChanged               *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_CONFIGURATIONCHANGED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_CONFIGURATIONCHANGED_STRUCT ; colId ++)
  {
    getElementConfigurationChanged( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get configurationSaved the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvConfigurationSaved(
  IO MsgBsmSihConfigurationSaved                 *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_CONFIGURATIONSAVED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_CONFIGURATIONSAVED_STRUCT ; colId ++)
  {
    getElementConfigurationSaved( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get configurationRollBack the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvConfigurationRollBack(
  IO MsgBsmSihConfigurationRollBack              *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_CONFIGURATIONROLLBACK_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_CONFIGURATIONROLLBACK_STRUCT ; colId ++)
  {
    getElementConfigurationRollBack( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get swActivationFailed the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvSwActivationFailed(
  IO MsgBsmSihSwActivationFailed                 *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_SWACTIVATIONFAILED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_SWACTIVATIONFAILED_STRUCT ; colId ++)
  {
    getElementSwActivationFailed( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get swActivationSuccess the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvSwActivationSuccess(
  IO MsgBsmSihSwActivationSuccess                *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_SWACTIVATIONSUCCESS_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_SWACTIVATIONSUCCESS_STRUCT ; colId ++)
  {
    getElementSwActivationSuccess( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get swInstallFailed the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvSwInstallFailed(
  IO MsgBsmSihSwInstallFailed                    *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_SWINSTALLFAILED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_SWINSTALLFAILED_STRUCT ; colId ++)
  {
    getElementSwInstallFailed( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get swInstallSuccess the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvSwInstallSuccess(
  IO MsgBsmSihSwInstallSuccess                   *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_SWINSTALLSUCCESS_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_SWINSTALLSUCCESS_STRUCT ; colId ++)
  {
    getElementSwInstallSuccess( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get enbRegistrationReq the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvEnbRegistrationReq(
  IO MsgBsmSihEnbRegistrationReq                 *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_ENBREGISTRATIONREQ_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_ENBREGISTRATIONREQ_STRUCT ; colId ++)
  {
    getElementEnbRegistrationReq( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get enbOperationalStateChanged the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvEnbOperationalStateChanged(
  IO MsgBsmSihEnbOperationalStateChanged         *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_ENBOPERATIONALSTATECHANGED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_ENBOPERATIONALSTATECHANGED_STRUCT ; colId ++)
  {
    getElementEnbOperationalStateChanged( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get enbAdminStateChanged the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvEnbAdminStateChanged(
  IO MsgBsmSihEnbAdminStateChanged               *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_ENBADMINSTATECHANGED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_ENBADMINSTATECHANGED_STRUCT ; colId ++)
  {
    getElementEnbAdminStateChanged( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get enbLocationChanged the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvEnbLocationChanged(
  IO MsgBsmSihEnbLocationChanged                 *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_ENBLOCATIONCHANGED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_ENBLOCATIONCHANGED_STRUCT ; colId ++)
  {
    getElementEnbLocationChanged( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get enbRebootInd the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvEnbRebootInd(
  IO MsgBsmSihEnbRebootInd                       *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_ENBREBOOTIND_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_ENBREBOOTIND_STRUCT ; colId ++)
  {
    getElementEnbRebootInd( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get noNeighborConfigured the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvNoNeighborConfigured(
  IO MsgBsmSihNoNeighborConfigured               *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_NONEIGHBORCONFIGURED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_NONEIGHBORCONFIGURED_STRUCT ; colId ++)
  {
    getElementNoNeighborConfigured( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get cellBarredInd the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvCellBarredInd(
  IO MsgBsmSihCellBarredInd                      *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_CELLBARREDIND_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_CELLBARREDIND_STRUCT ; colId ++)
  {
    getElementCellBarredInd( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get cellUnBarredInd the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvCellUnBarredInd(
  IO MsgBsmSihCellUnBarredInd                    *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_CELLUNBARREDIND_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_CELLUNBARREDIND_STRUCT ; colId ++)
  {
    getElementCellUnBarredInd( notiStruct , colId , notiObj );
  }
}
/**
 * @param notiStruct This is the notification structure from where TLV will be filled 
 * @param notiObj    notification TLV in which Response will be filled.
 * @section This function will get measurementCompleted the ColId information and fill the response noti Object TLV.
 * */
void convertStruct2TlvMeasurementCompleted(
  IO MsgBsmSihMeasurementCompleted               *notiStruct, 
  IO NotiObj                                     *notiObj 
  ) 
{
  ColId      colId = 0;
  notiObj->notiId = STRUCT_MEASUREMENTCOMPLETED_ID ;
  
  for(colId = FIRST_COL; colId <= MAX_COLS_IN_MEASUREMENTCOMPLETED_STRUCT ; colId ++)
  {
    getElementMeasurementCompleted( notiStruct , colId , notiObj );
  }
}
/* getElement   */
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementAlarmNotification(
  IN MsgBsmSihAlarmNotification                         *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_ALARMNOTIFICATION_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_ALARMNOTIFICATION_ALARMSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->alarmSequenceNumber, notiObj );
      break;
    case COL_ALARMNOTIFICATION_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_ALARMNOTIFICATION_ALARMTYPE:
      fillNotiTagLenUint32( colId, notiStruct->alarmType, notiObj );
      break;
    case COL_ALARMNOTIFICATION_ALARMID:
      fillNotiTagLenUint32( colId, notiStruct->alarmId, notiObj );
      break;
    case COL_ALARMNOTIFICATION_ALARMSEVERITY:
      fillNotiTagLenUint32( colId, notiStruct->alarmSeverity, notiObj );
      break;
    case COL_ALARMNOTIFICATION_ALARMCAUSE:
      fillNotiTagLenUint32( colId, notiStruct->alarmCause, notiObj );
      break;
    case COL_ALARMNOTIFICATION_ALARMLOCATION:
      fillNotiTagLenString( colId, notiStruct->alarmLocation, strlen(notiStruct->alarmLocation), notiObj );
      break;
    case COL_ALARMNOTIFICATION_ALARMADDITIONALTEXT:
      fillNotiTagLenString( colId, notiStruct->alarmAdditionalText, strlen(notiStruct->alarmAdditionalText), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_ALARMNOTIFICATION_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementMmeReset(
  IN MsgBsmSihMmeReset                                  *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_MMERESET_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_MMERESET_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_MMERESET_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_MMERESET_MMEIPADDR:
      fillNotiTagLenString( colId, notiStruct->mmeIpAddr, strlen(notiStruct->mmeIpAddr), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_MMERESET_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementFileUploadCompleted(
  IN MsgBsmSihFileUploadCompleted                       *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_FILEUPLOADCOMPLETED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_FILEUPLOADCOMPLETED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_FILEUPLOADCOMPLETED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_FILEUPLOADCOMPLETED_FILENAME:
      fillNotiTagLenString( colId, notiStruct->fileName, strlen(notiStruct->fileName), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_FILEUPLOADCOMPLETED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementFileUploadFailed(
  IN MsgBsmSihFileUploadFailed                          *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_FILEUPLOADFAILED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_FILEUPLOADFAILED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_FILEUPLOADFAILED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_FILEUPLOADFAILED_FILENAME:
      fillNotiTagLenString( colId, notiStruct->fileName, strlen(notiStruct->fileName), notiObj );
      break;
    case COL_FILEUPLOADFAILED_ERRORINFO:
      fillNotiTagLenString( colId, notiStruct->errorInfo, strlen(notiStruct->errorInfo), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_FILEUPLOADFAILED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementFileDownloadCompleted(
  IN MsgBsmSihFileDownloadCompleted                     *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_FILEDOWNLOADCOMPLETED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_FILEDOWNLOADCOMPLETED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_FILEDOWNLOADCOMPLETED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_FILEDOWNLOADCOMPLETED_FILENAME:
      fillNotiTagLenString( colId, notiStruct->fileName, strlen(notiStruct->fileName), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_FILEDOWNLOADCOMPLETED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementFileDownloadFailed(
  IN MsgBsmSihFileDownloadFailed                        *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_FILEDOWNLOADFAILED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_FILEDOWNLOADFAILED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_FILEDOWNLOADFAILED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_FILEDOWNLOADFAILED_FILENAME:
      fillNotiTagLenString( colId, notiStruct->fileName, strlen(notiStruct->fileName), notiObj );
      break;
    case COL_FILEDOWNLOADFAILED_ERRORINFO:
      fillNotiTagLenString( colId, notiStruct->errorInfo, strlen(notiStruct->errorInfo), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_FILEDOWNLOADFAILED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementMessageTraceCompleted(
  IN MsgBsmSihMessageTraceCompleted                     *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_MESSAGETRACECOMPLETED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_MESSAGETRACECOMPLETED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_MESSAGETRACECOMPLETED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_MESSAGETRACECOMPLETED_FILENAME:
      fillNotiTagLenString( colId, notiStruct->fileName, strlen(notiStruct->fileName), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_MESSAGETRACECOMPLETED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementMessageTraceFailed(
  IN MsgBsmSihMessageTraceFailed                        *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_MESSAGETRACEFAILED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_MESSAGETRACEFAILED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_MESSAGETRACEFAILED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_MESSAGETRACEFAILED_ERRORINFO:
      fillNotiTagLenString( colId, notiStruct->errorInfo, strlen(notiStruct->errorInfo), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_MESSAGETRACEFAILED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementCounterFileAvailable(
  IN MsgBsmSihCounterFileAvailable                      *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_COUNTERFILEAVAILABLE_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_COUNTERFILEAVAILABLE_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_COUNTERFILEAVAILABLE_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_COUNTERFILEAVAILABLE_FILENAME:
      fillNotiTagLenString( colId, notiStruct->fileName, strlen(notiStruct->fileName), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_COUNTERFILEAVAILABLE_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementCounterCollectionFailed(
  IN MsgBsmSihCounterCollectionFailed                   *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_COUNTERCOLLECTIONFAILED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_COUNTERCOLLECTIONFAILED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_COUNTERCOLLECTIONFAILED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_COUNTERCOLLECTIONFAILED_ERRORINFO:
      fillNotiTagLenString( colId, notiStruct->errorInfo, strlen(notiStruct->errorInfo), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_COUNTERCOLLECTIONFAILED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementConfigurationChanged(
  IN MsgBsmSihConfigurationChanged                      *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_CONFIGURATIONCHANGED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_CONFIGURATIONCHANGED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_CONFIGURATIONCHANGED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_CONFIGURATIONCHANGED_OAMIFTYPE:
      fillNotiTagLenUint32( colId, notiStruct->oamIfType, notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_CONFIGURATIONCHANGED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementConfigurationSaved(
  IN MsgBsmSihConfigurationSaved                        *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_CONFIGURATIONSAVED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_CONFIGURATIONSAVED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_CONFIGURATIONSAVED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_CONFIGURATIONSAVED_OAMIFTYPE:
      fillNotiTagLenUint32( colId, notiStruct->oamIfType, notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_CONFIGURATIONSAVED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementConfigurationRollBack(
  IN MsgBsmSihConfigurationRollBack                     *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_CONFIGURATIONROLLBACK_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_CONFIGURATIONROLLBACK_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_CONFIGURATIONROLLBACK_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_CONFIGURATIONROLLBACK_OAMIFTYPE:
      fillNotiTagLenUint32( colId, notiStruct->oamIfType, notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_CONFIGURATIONROLLBACK_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementSwActivationFailed(
  IN MsgBsmSihSwActivationFailed                        *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_SWACTIVATIONFAILED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_SWACTIVATIONFAILED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_SWACTIVATIONFAILED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_SWACTIVATIONFAILED_SWTYPE:
      fillNotiTagLenUint32( colId, notiStruct->swType, notiObj );
      break;
    case COL_SWACTIVATIONFAILED_VERSION:
      fillNotiTagLenString( colId, notiStruct->version, strlen(notiStruct->version), notiObj );
      break;
    case COL_SWACTIVATIONFAILED_ERRORINFO:
      fillNotiTagLenString( colId, notiStruct->errorInfo, strlen(notiStruct->errorInfo), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_SWACTIVATIONFAILED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementSwActivationSuccess(
  IN MsgBsmSihSwActivationSuccess                       *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_SWACTIVATIONSUCCESS_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_SWACTIVATIONSUCCESS_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_SWACTIVATIONSUCCESS_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_SWACTIVATIONSUCCESS_SWTYPE:
      fillNotiTagLenUint32( colId, notiStruct->swType, notiObj );
      break;
    case COL_SWACTIVATIONSUCCESS_VERSION:
      fillNotiTagLenString( colId, notiStruct->version, strlen(notiStruct->version), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_SWACTIVATIONSUCCESS_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementSwInstallFailed(
  IN MsgBsmSihSwInstallFailed                           *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_SWINSTALLFAILED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_SWINSTALLFAILED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_SWINSTALLFAILED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_SWINSTALLFAILED_FILENAME:
      fillNotiTagLenString( colId, notiStruct->fileName, strlen(notiStruct->fileName), notiObj );
      break;
    case COL_SWINSTALLFAILED_ERRORINFO:
      fillNotiTagLenString( colId, notiStruct->errorInfo, strlen(notiStruct->errorInfo), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_SWINSTALLFAILED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementSwInstallSuccess(
  IN MsgBsmSihSwInstallSuccess                          *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_SWINSTALLSUCCESS_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_SWINSTALLSUCCESS_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_SWINSTALLSUCCESS_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_SWINSTALLSUCCESS_FILENAME:
      fillNotiTagLenString( colId, notiStruct->fileName, strlen(notiStruct->fileName), notiObj );
      break;
    case COL_SWINSTALLSUCCESS_VERSION:
      fillNotiTagLenString( colId, notiStruct->version, strlen(notiStruct->version), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_SWINSTALLSUCCESS_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementEnbRegistrationReq(
  IN MsgBsmSihEnbRegistrationReq                        *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_ENBREGISTRATIONREQ_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_ENBREGISTRATIONREQ_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_ENBREGISTRATIONREQ_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_ENBREGISTRATIONREQ_PRODUCTID:
      fillNotiTagLenString( colId, notiStruct->productId, strlen(notiStruct->productId), notiObj );
      break;
    case COL_ENBREGISTRATIONREQ_LONGITUDE:
      fillNotiTagLenString( colId, notiStruct->longitude, strlen(notiStruct->longitude), notiObj );
      break;
    case COL_ENBREGISTRATIONREQ_LATITUDE:
      fillNotiTagLenString( colId, notiStruct->latitude, strlen(notiStruct->latitude), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_ENBREGISTRATIONREQ_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementEnbOperationalStateChanged(
  IN MsgBsmSihEnbOperationalStateChanged                *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_ENBOPERATIONALSTATECHANGED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_ENBOPERATIONALSTATECHANGED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_ENBOPERATIONALSTATECHANGED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_ENBOPERATIONALSTATECHANGED_OPERATIONALSTATE:
      fillNotiTagLenUint32( colId, notiStruct->operationalState, notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_ENBOPERATIONALSTATECHANGED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementEnbAdminStateChanged(
  IN MsgBsmSihEnbAdminStateChanged                      *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_ENBADMINSTATECHANGED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_ENBADMINSTATECHANGED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_ENBADMINSTATECHANGED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_ENBADMINSTATECHANGED_ADMINSTATE:
      fillNotiTagLenUint32( colId, notiStruct->adminState, notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_ENBADMINSTATECHANGED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementEnbLocationChanged(
  IN MsgBsmSihEnbLocationChanged                        *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_ENBLOCATIONCHANGED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_ENBLOCATIONCHANGED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_ENBLOCATIONCHANGED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_ENBLOCATIONCHANGED_LONGITUDE:
      fillNotiTagLenString( colId, notiStruct->longitude, strlen(notiStruct->longitude), notiObj );
      break;
    case COL_ENBLOCATIONCHANGED_LATITUDE:
      fillNotiTagLenString( colId, notiStruct->latitude, strlen(notiStruct->latitude), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_ENBLOCATIONCHANGED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementEnbRebootInd(
  IN MsgBsmSihEnbRebootInd                              *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_ENBREBOOTIND_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_ENBREBOOTIND_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_ENBREBOOTIND_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_ENBREBOOTIND_REBOOTREASON:
      fillNotiTagLenString( colId, notiStruct->rebootReason, strlen(notiStruct->rebootReason), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_ENBREBOOTIND_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementNoNeighborConfigured(
  IN MsgBsmSihNoNeighborConfigured                      *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_NONEIGHBORCONFIGURED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_NONEIGHBORCONFIGURED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_NONEIGHBORCONFIGURED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_NONEIGHBORCONFIGURED_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementCellBarredInd(
  IN MsgBsmSihCellBarredInd                             *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_CELLBARREDIND_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_CELLBARREDIND_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_CELLBARREDIND_CELLID:
      fillNotiTagLenUint8( colId, notiStruct->cellId, notiObj );
      break;
    case COL_CELLBARREDIND_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_CELLBARREDIND_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementCellUnBarredInd(
  IN MsgBsmSihCellUnBarredInd                           *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_CELLUNBARREDIND_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_CELLUNBARREDIND_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_CELLUNBARREDIND_CELLID:
      fillNotiTagLenUint8( colId, notiStruct->cellId, notiObj );
      break;
    case COL_CELLUNBARREDIND_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_CELLUNBARREDIND_ID , 1, colId );
      break;
  }
}
/**
 * @param notiStruct  : Notification structure 
 * @param colId       : Column ID 
 * @param notiObj     : Notification Object TLV in which Response will be filled.
 * @section This function is used to get and fill the element in TLV format
 * */
void getElementMeasurementCompleted(
  IN MsgBsmSihMeasurementCompleted                      *notiStruct,
  IN ColId                                              colId,
  IO NotiObj                                            *notiObj
  )
{

  switch(colId)
  {
    case COL_MEASUREMENTCOMPLETED_ENODEBID:
      fillNotiTagLenUint32( colId, notiStruct->enodebId, notiObj );
      break;
    case COL_MEASUREMENTCOMPLETED_NOTIFICATIONSEQUENCENUMBER:
      fillNotiTagLenUint32( colId, notiStruct->notificationSequenceNumber, notiObj );
      break;
    case COL_MEASUREMENTCOMPLETED_DATEANDTIMESTAMP:
      fillNotiTagLenString( colId, notiStruct->dateAndTimeStamp, strlen(notiStruct->dateAndTimeStamp), notiObj );
      break;
    case COL_MEASUREMENTCOMPLETED_PROFILEID:
      fillNotiTagLenUint32( colId, notiStruct->profileId, notiObj );
      break;
    case COL_MEASUREMENTCOMPLETED_STOPPEDREASON:
      fillNotiTagLenString( colId, notiStruct->stoppedReason, strlen(notiStruct->stoppedReason), notiObj );
      break;
    default:
      BS_ERROR_INVALID_COLID_RCVD( STRUCT_MEASUREMENTCOMPLETED_ID , 1, colId );
      break;
  }
}
/* Tlv2Struct   */
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihalarmNotification   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructAlarmNotification(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihAlarmNotification                  *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_ALARMNOTIFICATION_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_ALARMNOTIFICATION_ALARMSEQUENCENUMBER:
        config->alarmSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_ALARMNOTIFICATION_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_ALARMNOTIFICATION_ALARMTYPE:
        config->alarmType = getUint32FromArray(tlv->data);
      break;
      case COL_ALARMNOTIFICATION_ALARMID:
        config->alarmId = getUint32FromArray(tlv->data);
      break;
      case COL_ALARMNOTIFICATION_ALARMSEVERITY:
        config->alarmSeverity = getUint32FromArray(tlv->data);
      break;
      case COL_ALARMNOTIFICATION_ALARMCAUSE:
        config->alarmCause = getUint32FromArray(tlv->data);
      break;
      case COL_ALARMNOTIFICATION_ALARMLOCATION:
        getBytesFromArray( tlv->data , tlv->len , config->alarmLocation);
      break;
      case COL_ALARMNOTIFICATION_ALARMADDITIONALTEXT:
        getBytesFromArray( tlv->data , tlv->len , config->alarmAdditionalText);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_ALARMNOTIFICATION_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihmmeReset   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructMmeReset(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihMmeReset                           *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_MMERESET_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_MMERESET_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_MMERESET_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_MMERESET_MMEIPADDR:
        getBytesFromArray( tlv->data , tlv->len , config->mmeIpAddr);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_MMERESET_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihfileUploadCompleted   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructFileUploadCompleted(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihFileUploadCompleted                *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_FILEUPLOADCOMPLETED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_FILEUPLOADCOMPLETED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_FILEUPLOADCOMPLETED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_FILEUPLOADCOMPLETED_FILENAME:
        getBytesFromArray( tlv->data , tlv->len , config->fileName);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_FILEUPLOADCOMPLETED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihfileUploadFailed   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructFileUploadFailed(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihFileUploadFailed                   *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_FILEUPLOADFAILED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_FILEUPLOADFAILED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_FILEUPLOADFAILED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_FILEUPLOADFAILED_FILENAME:
        getBytesFromArray( tlv->data , tlv->len , config->fileName);
      break;
      case COL_FILEUPLOADFAILED_ERRORINFO:
        getBytesFromArray( tlv->data , tlv->len , config->errorInfo);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_FILEUPLOADFAILED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihfileDownloadCompleted   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructFileDownloadCompleted(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihFileDownloadCompleted              *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_FILEDOWNLOADCOMPLETED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_FILEDOWNLOADCOMPLETED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_FILEDOWNLOADCOMPLETED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_FILEDOWNLOADCOMPLETED_FILENAME:
        getBytesFromArray( tlv->data , tlv->len , config->fileName);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_FILEDOWNLOADCOMPLETED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihfileDownloadFailed   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructFileDownloadFailed(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihFileDownloadFailed                 *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_FILEDOWNLOADFAILED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_FILEDOWNLOADFAILED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_FILEDOWNLOADFAILED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_FILEDOWNLOADFAILED_FILENAME:
        getBytesFromArray( tlv->data , tlv->len , config->fileName);
      break;
      case COL_FILEDOWNLOADFAILED_ERRORINFO:
        getBytesFromArray( tlv->data , tlv->len , config->errorInfo);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_FILEDOWNLOADFAILED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihmessageTraceCompleted   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructMessageTraceCompleted(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihMessageTraceCompleted              *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_MESSAGETRACECOMPLETED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_MESSAGETRACECOMPLETED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_MESSAGETRACECOMPLETED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_MESSAGETRACECOMPLETED_FILENAME:
        getBytesFromArray( tlv->data , tlv->len , config->fileName);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_MESSAGETRACECOMPLETED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihmessageTraceFailed   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructMessageTraceFailed(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihMessageTraceFailed                 *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_MESSAGETRACEFAILED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_MESSAGETRACEFAILED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_MESSAGETRACEFAILED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_MESSAGETRACEFAILED_ERRORINFO:
        getBytesFromArray( tlv->data , tlv->len , config->errorInfo);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_MESSAGETRACEFAILED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihcounterFileAvailable   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructCounterFileAvailable(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihCounterFileAvailable               *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_COUNTERFILEAVAILABLE_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_COUNTERFILEAVAILABLE_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_COUNTERFILEAVAILABLE_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_COUNTERFILEAVAILABLE_FILENAME:
        getBytesFromArray( tlv->data , tlv->len , config->fileName);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_COUNTERFILEAVAILABLE_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihcounterCollectionFailed   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructCounterCollectionFailed(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihCounterCollectionFailed            *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_COUNTERCOLLECTIONFAILED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_COUNTERCOLLECTIONFAILED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_COUNTERCOLLECTIONFAILED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_COUNTERCOLLECTIONFAILED_ERRORINFO:
        getBytesFromArray( tlv->data , tlv->len , config->errorInfo);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_COUNTERCOLLECTIONFAILED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihconfigurationChanged   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructConfigurationChanged(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihConfigurationChanged               *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_CONFIGURATIONCHANGED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_CONFIGURATIONCHANGED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_CONFIGURATIONCHANGED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_CONFIGURATIONCHANGED_OAMIFTYPE:
        config->oamIfType = getUint32FromArray(tlv->data);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_CONFIGURATIONCHANGED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihconfigurationSaved   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructConfigurationSaved(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihConfigurationSaved                 *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_CONFIGURATIONSAVED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_CONFIGURATIONSAVED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_CONFIGURATIONSAVED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_CONFIGURATIONSAVED_OAMIFTYPE:
        config->oamIfType = getUint32FromArray(tlv->data);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_CONFIGURATIONSAVED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihconfigurationRollBack   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructConfigurationRollBack(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihConfigurationRollBack              *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_CONFIGURATIONROLLBACK_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_CONFIGURATIONROLLBACK_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_CONFIGURATIONROLLBACK_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_CONFIGURATIONROLLBACK_OAMIFTYPE:
        config->oamIfType = getUint32FromArray(tlv->data);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_CONFIGURATIONROLLBACK_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihswActivationFailed   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructSwActivationFailed(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihSwActivationFailed                 *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_SWACTIVATIONFAILED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_SWACTIVATIONFAILED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_SWACTIVATIONFAILED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_SWACTIVATIONFAILED_SWTYPE:
        config->swType = getUint32FromArray(tlv->data);
      break;
      case COL_SWACTIVATIONFAILED_VERSION:
        getBytesFromArray( tlv->data , tlv->len , config->version);
      break;
      case COL_SWACTIVATIONFAILED_ERRORINFO:
        getBytesFromArray( tlv->data , tlv->len , config->errorInfo);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_SWACTIVATIONFAILED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihswActivationSuccess   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructSwActivationSuccess(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihSwActivationSuccess                *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_SWACTIVATIONSUCCESS_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_SWACTIVATIONSUCCESS_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_SWACTIVATIONSUCCESS_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_SWACTIVATIONSUCCESS_SWTYPE:
        config->swType = getUint32FromArray(tlv->data);
      break;
      case COL_SWACTIVATIONSUCCESS_VERSION:
        getBytesFromArray( tlv->data , tlv->len , config->version);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_SWACTIVATIONSUCCESS_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihswInstallFailed   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructSwInstallFailed(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihSwInstallFailed                    *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_SWINSTALLFAILED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_SWINSTALLFAILED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_SWINSTALLFAILED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_SWINSTALLFAILED_FILENAME:
        getBytesFromArray( tlv->data , tlv->len , config->fileName);
      break;
      case COL_SWINSTALLFAILED_ERRORINFO:
        getBytesFromArray( tlv->data , tlv->len , config->errorInfo);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_SWINSTALLFAILED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihswInstallSuccess   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructSwInstallSuccess(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihSwInstallSuccess                   *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_SWINSTALLSUCCESS_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_SWINSTALLSUCCESS_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_SWINSTALLSUCCESS_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_SWINSTALLSUCCESS_FILENAME:
        getBytesFromArray( tlv->data , tlv->len , config->fileName);
      break;
      case COL_SWINSTALLSUCCESS_VERSION:
        getBytesFromArray( tlv->data , tlv->len , config->version);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_SWINSTALLSUCCESS_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihenbRegistrationReq   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructEnbRegistrationReq(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihEnbRegistrationReq                 *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_ENBREGISTRATIONREQ_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_ENBREGISTRATIONREQ_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_ENBREGISTRATIONREQ_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_ENBREGISTRATIONREQ_PRODUCTID:
        getBytesFromArray( tlv->data , tlv->len , config->productId);
      break;
      case COL_ENBREGISTRATIONREQ_LONGITUDE:
        getBytesFromArray( tlv->data , tlv->len , config->longitude);
      break;
      case COL_ENBREGISTRATIONREQ_LATITUDE:
        getBytesFromArray( tlv->data , tlv->len , config->latitude);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_ENBREGISTRATIONREQ_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihenbOperationalStateChanged   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructEnbOperationalStateChanged(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihEnbOperationalStateChanged         *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_ENBOPERATIONALSTATECHANGED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_ENBOPERATIONALSTATECHANGED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_ENBOPERATIONALSTATECHANGED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_ENBOPERATIONALSTATECHANGED_OPERATIONALSTATE:
        config->operationalState = getUint32FromArray(tlv->data);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_ENBOPERATIONALSTATECHANGED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihenbAdminStateChanged   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructEnbAdminStateChanged(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihEnbAdminStateChanged               *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_ENBADMINSTATECHANGED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_ENBADMINSTATECHANGED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_ENBADMINSTATECHANGED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_ENBADMINSTATECHANGED_ADMINSTATE:
        config->adminState = getUint32FromArray(tlv->data);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_ENBADMINSTATECHANGED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihenbLocationChanged   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructEnbLocationChanged(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihEnbLocationChanged                 *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_ENBLOCATIONCHANGED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_ENBLOCATIONCHANGED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_ENBLOCATIONCHANGED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_ENBLOCATIONCHANGED_LONGITUDE:
        getBytesFromArray( tlv->data , tlv->len , config->longitude);
      break;
      case COL_ENBLOCATIONCHANGED_LATITUDE:
        getBytesFromArray( tlv->data , tlv->len , config->latitude);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_ENBLOCATIONCHANGED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihenbRebootInd   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructEnbRebootInd(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihEnbRebootInd                       *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_ENBREBOOTIND_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_ENBREBOOTIND_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_ENBREBOOTIND_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_ENBREBOOTIND_REBOOTREASON:
        getBytesFromArray( tlv->data , tlv->len , config->rebootReason);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_ENBREBOOTIND_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihnoNeighborConfigured   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructNoNeighborConfigured(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihNoNeighborConfigured               *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_NONEIGHBORCONFIGURED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_NONEIGHBORCONFIGURED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_NONEIGHBORCONFIGURED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_NONEIGHBORCONFIGURED_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihcellBarredInd   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructCellBarredInd(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihCellBarredInd                      *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_CELLBARREDIND_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_CELLBARREDIND_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_CELLBARREDIND_CELLID:
        config->cellId = getUint8FromArray(tlv->data);
      break;
      case COL_CELLBARREDIND_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_CELLBARREDIND_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihcellUnBarredInd   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructCellUnBarredInd(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihCellUnBarredInd                    *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_CELLUNBARREDIND_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_CELLUNBARREDIND_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_CELLUNBARREDIND_CELLID:
        config->cellId = getUint8FromArray(tlv->data);
      break;
      case COL_CELLUNBARREDIND_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_CELLUNBARREDIND_ID , 1, tlv->tagColId );
      break;
    }
  }
}
/**
 * @param notiObj *notiObj of TLV in from which Response will be filled.
 * @param configBsmSihmeasurementCompleted   Structure where data will be filled
 * @section This function decodes TLVs and fill the response structure.
 * */
void tlv2StructMeasurementCompleted(
  IO NotiObj                                     *notiObj, 
  IO MsgBsmSihMeasurementCompleted               *config 
  ) 
{
  UINT8         i = 0;
  NotiTlvInfo  *tlv = NULL;
  
  for(i = 0; i < notiObj->numTlvs ; i ++)
  {
    tlv = &(notiObj->notiTlvInfo[i]);
    switch(tlv->tagColId)
    {
      case COL_MEASUREMENTCOMPLETED_ENODEBID:
        config->enodebId = getUint32FromArray(tlv->data);
      break;
      case COL_MEASUREMENTCOMPLETED_NOTIFICATIONSEQUENCENUMBER:
        config->notificationSequenceNumber = getUint32FromArray(tlv->data);
      break;
      case COL_MEASUREMENTCOMPLETED_DATEANDTIMESTAMP:
        getBytesFromArray( tlv->data , tlv->len , config->dateAndTimeStamp);
      break;
      case COL_MEASUREMENTCOMPLETED_PROFILEID:
        config->profileId = getUint32FromArray(tlv->data);
      break;
      case COL_MEASUREMENTCOMPLETED_STOPPEDREASON:
        getBytesFromArray( tlv->data , tlv->len , config->stoppedReason);
      break;
      default:
        BS_ERROR_INVALID_COLID_RCVD( STRUCT_MEASUREMENTCOMPLETED_ID , 1, tlv->tagColId );
      break;
    }
  }
}

